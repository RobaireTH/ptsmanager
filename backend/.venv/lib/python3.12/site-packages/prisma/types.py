# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
                    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _int
    status: _str
    email_verified: _bool
    email_verification_token: Optional[_str]
    password_reset_token: Optional[_str]
    password_reset_expires_at: Optional[_str]
    refresh_token_hash: Optional[_str]
    refresh_token_expires_at: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    parent: 'ParentCreateNestedWithoutRelationsInput'
    teacher: 'TeacherCreateNestedWithoutRelationsInput'
    sentMessages: 'MessageCreateManyNestedWithoutRelationsInput'
    receivedMessages: 'MessageCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    name: _str
    email: _str
    role: _str
    password_hash: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _int
    status: _str
    email_verified: _bool
    email_verification_token: Optional[_str]
    password_reset_token: Optional[_str]
    password_reset_expires_at: Optional[_str]
    refresh_token_hash: Optional[_str]
    refresh_token_expires_at: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    name: _str
    email: _str
    role: _str
    password_hash: _str

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    email: _str
    role: _str
    password_hash: _str
    status: _str
    email_verified: _bool
    email_verification_token: Optional[_str]
    password_reset_token: Optional[_str]
    password_reset_expires_at: Optional[_str]
    refresh_token_hash: Optional[_str]
    refresh_token_expires_at: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    parent: 'ParentUpdateOneWithoutRelationsInput'
    teacher: 'TeacherUpdateOneWithoutRelationsInput'
    sentMessages: 'MessageUpdateManyWithoutRelationsInput'
    receivedMessages: 'MessageUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    email: _str
    role: _str
    password_hash: _str
    status: _str
    email_verified: _bool
    email_verification_token: Optional[_str]
    password_reset_token: Optional[_str]
    password_reset_expires_at: Optional[_str]
    refresh_token_hash: Optional[_str]
    refresh_token_expires_at: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_name_OrderByInput = TypedDict(
    '_User_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_role_OrderByInput = TypedDict(
    '_User_role_OrderByInput',
    {
        'role': 'SortOrder',
    },
    total=True
)

_User_password_hash_OrderByInput = TypedDict(
    '_User_password_hash_OrderByInput',
    {
        'password_hash': 'SortOrder',
    },
    total=True
)

_User_status_OrderByInput = TypedDict(
    '_User_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_User_email_verified_OrderByInput = TypedDict(
    '_User_email_verified_OrderByInput',
    {
        'email_verified': 'SortOrder',
    },
    total=True
)

_User_email_verification_token_OrderByInput = TypedDict(
    '_User_email_verification_token_OrderByInput',
    {
        'email_verification_token': 'SortOrder',
    },
    total=True
)

_User_password_reset_token_OrderByInput = TypedDict(
    '_User_password_reset_token_OrderByInput',
    {
        'password_reset_token': 'SortOrder',
    },
    total=True
)

_User_password_reset_expires_at_OrderByInput = TypedDict(
    '_User_password_reset_expires_at_OrderByInput',
    {
        'password_reset_expires_at': 'SortOrder',
    },
    total=True
)

_User_refresh_token_hash_OrderByInput = TypedDict(
    '_User_refresh_token_hash_OrderByInput',
    {
        'refresh_token_hash': 'SortOrder',
    },
    total=True
)

_User_refresh_token_expires_at_OrderByInput = TypedDict(
    '_User_refresh_token_expires_at_OrderByInput',
    {
        'refresh_token_expires_at': 'SortOrder',
    },
    total=True
)

_User_created_at_OrderByInput = TypedDict(
    '_User_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_User_updated_at_OrderByInput = TypedDict(
    '_User_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_name_OrderByInput',
    '_User_email_OrderByInput',
    '_User_role_OrderByInput',
    '_User_password_hash_OrderByInput',
    '_User_status_OrderByInput',
    '_User_email_verified_OrderByInput',
    '_User_email_verification_token_OrderByInput',
    '_User_password_reset_token_OrderByInput',
    '_User_password_reset_expires_at_OrderByInput',
    '_User_refresh_token_hash_OrderByInput',
    '_User_refresh_token_expires_at_OrderByInput',
    '_User_created_at_OrderByInput',
    '_User_updated_at_OrderByInput',
]



# recursive User types
# TODO: cleanup these types



UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'UserWhereInput',
        'is_not': 'UserWhereInput',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'UserWhereInput'
    none: 'UserWhereInput'
    every: 'UserWhereInput'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    parent: Union[bool, 'ParentArgsFromUser']
    teacher: Union[bool, 'TeacherArgsFromUser']
    sentMessages: Union[bool, 'FindManyMessageArgsFromUser']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromUser']


class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    parent: Union[bool, 'ParentArgsFromUser']
    teacher: Union[bool, 'TeacherArgsFromUser']
    sentMessages: Union[bool, 'FindManyMessageArgsFromUser']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromUser']


class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class ParentIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']
    students: Union[bool, 'FindManyStudentArgsFromUser']


class ParentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ParentIncludeFromParent'


class FindManyParentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParentOrderByInput', List['ParentOrderByInput']]
    where: 'ParentWhereInput'
    cursor: 'ParentWhereUniqueInput'
    distinct: List['ParentScalarFieldKeys']
    include: 'ParentIncludeFromParent'


class TeacherIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']
    classes: Union[bool, 'FindManyClassModelArgsFromUser']
    results: Union[bool, 'FindManyResultArgsFromUser']
    attendance: Union[bool, 'FindManyAttendanceArgsFromUser']


class TeacherArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeacherIncludeFromTeacher'


class FindManyTeacherArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeacherOrderByInput', List['TeacherOrderByInput']]
    where: 'TeacherWhereInput'
    cursor: 'TeacherWhereUniqueInput'
    distinct: List['TeacherScalarFieldKeys']
    include: 'TeacherIncludeFromTeacher'


class ClassModelIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    teacher: Union[bool, 'TeacherArgsFromUser']
    students: Union[bool, 'FindManyStudentArgsFromUser']
    results: Union[bool, 'FindManyResultArgsFromUser']
    attendance: Union[bool, 'FindManyAttendanceArgsFromUser']


class ClassModelArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ClassModelIncludeFromClassModel'


class FindManyClassModelArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ClassModelOrderByInput', List['ClassModelOrderByInput']]
    where: 'ClassModelWhereInput'
    cursor: 'ClassModelWhereUniqueInput'
    distinct: List['ClassModelScalarFieldKeys']
    include: 'ClassModelIncludeFromClassModel'


class StudentIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    parent: Union[bool, 'ParentArgsFromUser']
    classModel: Union[bool, 'ClassModelArgsFromUser']
    results: Union[bool, 'FindManyResultArgsFromUser']
    attendance: Union[bool, 'FindManyAttendanceArgsFromUser']


class StudentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'StudentIncludeFromStudent'


class FindManyStudentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudent'


class EventIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class EventArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'EventIncludeFromEvent'


class FindManyEventArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEvent'


class MessageIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    sender: Union[bool, 'UserArgsFromUser']
    recipient: Union[bool, 'UserArgsFromUser']


class MessageArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ResultIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    student: Union[bool, 'StudentArgsFromUser']
    classModel: Union[bool, 'ClassModelArgsFromUser']
    teacher: Union[bool, 'TeacherArgsFromUser']


class ResultArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ResultIncludeFromResult'


class FindManyResultArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ResultOrderByInput', List['ResultOrderByInput']]
    where: 'ResultWhereInput'
    cursor: 'ResultWhereUniqueInput'
    distinct: List['ResultScalarFieldKeys']
    include: 'ResultIncludeFromResult'


class AttendanceIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    student: Union[bool, 'StudentArgsFromUser']
    classModel: Union[bool, 'ClassModelArgsFromUser']
    teacher: Union[bool, 'TeacherArgsFromUser']


class AttendanceArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AttendanceIncludeFromAttendance'


class FindManyAttendanceArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AttendanceOrderByInput', List['AttendanceOrderByInput']]
    where: 'AttendanceWhereInput'
    cursor: 'AttendanceWhereUniqueInput'
    distinct: List['AttendanceScalarFieldKeys']
    include: 'AttendanceIncludeFromAttendance'




FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    password_hash: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    email_verified: Union[_bool, 'types.BooleanFilter']
    email_verification_token: Union[None, _str, 'types.StringFilter']
    password_reset_token: Union[None, _str, 'types.StringFilter']
    password_reset_expires_at: Union[None, _str, 'types.StringFilter']
    refresh_token_hash: Union[None, _str, 'types.StringFilter']
    refresh_token_expires_at: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    parent: 'ParentRelationFilter'
    teacher: 'TeacherRelationFilter'
    sentMessages: 'MessageListRelationFilter'
    receivedMessages: 'MessageListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInput', List['UserWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInput']
    OR: List['UserWhereInput']
    NOT: List['UserWhereInput']



# aggregate User types


class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    password_hash: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    email_verified: Union[_bool, 'types.BooleanWithAggregatesFilter']
    email_verification_token: Union[_str, 'types.StringWithAggregatesFilter']
    password_reset_token: Union[_str, 'types.StringWithAggregatesFilter']
    password_reset_expires_at: Union[_str, 'types.StringWithAggregatesFilter']
    refresh_token_hash: Union[_str, 'types.StringWithAggregatesFilter']
    refresh_token_expires_at: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInput']
    OR: List['UserScalarWhereWithAggregatesInput']
    NOT: List['UserScalarWhereWithAggregatesInput']



class UserGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    email: _str
    role: _str
    password_hash: _str
    status: _str
    email_verified: _bool
    email_verification_token: _str
    password_reset_token: _str
    password_reset_expires_at: _str
    refresh_token_hash: _str
    refresh_token_expires_at: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""
    id: float


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""
    id: _int


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _int
    name: _str
    email: _str
    role: _str
    password_hash: _str
    status: _str
    email_verified: _bool
    email_verification_token: _str
    password_reset_token: _str
    password_reset_expires_at: _str
    refresh_token_hash: _str
    refresh_token_expires_at: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    name: bool
    email: bool
    role: bool
    password_hash: bool
    status: bool
    email_verified: bool
    email_verification_token: bool
    password_reset_token: bool
    password_reset_expires_at: bool
    refresh_token_hash: bool
    refresh_token_expires_at: bool
    created_at: bool
    updated_at: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    name: bool
    email: bool
    role: bool
    password_hash: bool
    status: bool
    email_verified: bool
    email_verification_token: bool
    password_reset_token: bool
    password_reset_expires_at: bool
    refresh_token_hash: bool
    refresh_token_expires_at: bool
    created_at: bool
    updated_at: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""
    id: bool


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'email': bool,
        'role': bool,
        'password_hash': bool,
        'status': bool,
        'email_verified': bool,
        'email_verification_token': bool,
        'password_reset_token': bool,
        'password_reset_expires_at': bool,
        'refresh_token_hash': bool,
        'refresh_token_expires_at': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'email': int,
        'role': int,
        'password_hash': int,
        'status': int,
        'email_verified': int,
        'email_verification_token': int,
        'password_reset_token': int,
        'password_reset_expires_at': int,
        'refresh_token_hash': int,
        'refresh_token_expires_at': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'name',
    'email',
    'role',
    'password_hash',
    'status',
    'email_verified',
    'email_verification_token',
    'password_reset_token',
    'password_reset_expires_at',
    'refresh_token_hash',
    'refresh_token_expires_at',
    'created_at',
    'updated_at',
    'parent',
    'teacher',
    'sentMessages',
    'receivedMessages',
]
UserScalarFieldKeys = Literal[
    'id',
    'name',
    'email',
    'role',
    'password_hash',
    'status',
    'email_verified',
    'email_verification_token',
    'password_reset_token',
    'password_reset_expires_at',
    'refresh_token_hash',
    'refresh_token_expires_at',
    'created_at',
    'updated_at',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'parent',
        'teacher',
        'sentMessages',
        'receivedMessages',
    ]

# Parent types

class ParentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Parent create method"""
    id: _int
    user_id: _int
    phone: Optional[_str]
    profile_picture_url: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'
    students: 'StudentCreateManyNestedWithoutRelationsInput'


class ParentCreateInput(ParentOptionalCreateInput):
    """Required arguments to the Parent create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ParentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Parent create method, without relations"""
    id: _int
    user_id: _int
    phone: Optional[_str]
    profile_picture_url: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class ParentCreateWithoutRelationsInput(ParentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Parent create method, without relations"""

class ParentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ParentCreateWithoutRelationsInput'
    where: 'ParentWhereUniqueInput'

class ParentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ParentCreateWithoutRelationsInput'
    connect: 'ParentWhereUniqueInput'
    connect_or_create: 'ParentConnectOrCreateWithoutRelationsInput'


class ParentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ParentCreateWithoutRelationsInput', List['ParentCreateWithoutRelationsInput']]
    connect: Union['ParentWhereUniqueInput', List['ParentWhereUniqueInput']]
    connect_or_create: Union['ParentConnectOrCreateWithoutRelationsInput', List['ParentConnectOrCreateWithoutRelationsInput']]

_ParentWhereUnique_id_Input = TypedDict(
    '_ParentWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_ParentWhereUnique_user_id_Input = TypedDict(
    '_ParentWhereUnique_user_id_Input',
    {
        'user_id': '_int',
    },
    total=True
)

ParentWhereUniqueInput = Union[
    '_ParentWhereUnique_id_Input',
    '_ParentWhereUnique_user_id_Input',
]


class ParentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    phone: Optional[_str]
    profile_picture_url: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    students: 'StudentUpdateManyWithoutRelationsInput'


class ParentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    phone: Optional[_str]
    profile_picture_url: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class ParentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ParentCreateWithoutRelationsInput']
    connect: List['ParentWhereUniqueInput']
    connect_or_create: List['ParentConnectOrCreateWithoutRelationsInput']
    set: List['ParentWhereUniqueInput']
    disconnect: List['ParentWhereUniqueInput']
    delete: List['ParentWhereUniqueInput']

    # TODO
    # update: List['ParentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ParentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ParentScalarWhereInput']
    # upsert: List['ParentUpserteWithWhereUniqueWithoutRelationsInput']


class ParentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ParentCreateWithoutRelationsInput'
    connect: 'ParentWhereUniqueInput'
    connect_or_create: 'ParentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ParentUpdateInput'
    # upsert: 'ParentUpsertWithoutRelationsInput'


class ParentUpsertInput(TypedDict):
    create: 'ParentCreateInput'
    update: 'ParentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Parent_id_OrderByInput = TypedDict(
    '_Parent_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Parent_user_id_OrderByInput = TypedDict(
    '_Parent_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_Parent_phone_OrderByInput = TypedDict(
    '_Parent_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Parent_profile_picture_url_OrderByInput = TypedDict(
    '_Parent_profile_picture_url_OrderByInput',
    {
        'profile_picture_url': 'SortOrder',
    },
    total=True
)

_Parent_created_at_OrderByInput = TypedDict(
    '_Parent_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Parent_updated_at_OrderByInput = TypedDict(
    '_Parent_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

ParentOrderByInput = Union[
    '_Parent_id_OrderByInput',
    '_Parent_user_id_OrderByInput',
    '_Parent_phone_OrderByInput',
    '_Parent_profile_picture_url_OrderByInput',
    '_Parent_created_at_OrderByInput',
    '_Parent_updated_at_OrderByInput',
]



# recursive Parent types
# TODO: cleanup these types



ParentRelationFilter = TypedDict(
    'ParentRelationFilter',
    {
        'is': 'ParentWhereInput',
        'is_not': 'ParentWhereInput',
    },
    total=False,
)


class ParentListRelationFilter(TypedDict, total=False):
    some: 'ParentWhereInput'
    none: 'ParentWhereInput'
    every: 'ParentWhereInput'


class ParentInclude(TypedDict, total=False):
    """Parent relational arguments"""
    user: Union[bool, 'UserArgsFromParent']
    students: Union[bool, 'FindManyStudentArgsFromParent']


class UserIncludeFromParent(TypedDict, total=False):
    """Relational arguments for Parent"""
    parent: Union[bool, 'ParentArgsFromParent']
    teacher: Union[bool, 'TeacherArgsFromParent']
    sentMessages: Union[bool, 'FindManyMessageArgsFromParent']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromParent']


class UserArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class ParentIncludeFromParent(TypedDict, total=False):
    """Relational arguments for Parent"""
    user: Union[bool, 'UserArgsFromParent']
    students: Union[bool, 'FindManyStudentArgsFromParent']


class ParentArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    include: 'ParentIncludeFromParent'


class FindManyParentArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    take: int
    skip: int
    order_by: Union['ParentOrderByInput', List['ParentOrderByInput']]
    where: 'ParentWhereInput'
    cursor: 'ParentWhereUniqueInput'
    distinct: List['ParentScalarFieldKeys']
    include: 'ParentIncludeFromParent'


class TeacherIncludeFromParent(TypedDict, total=False):
    """Relational arguments for Parent"""
    user: Union[bool, 'UserArgsFromParent']
    classes: Union[bool, 'FindManyClassModelArgsFromParent']
    results: Union[bool, 'FindManyResultArgsFromParent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromParent']


class TeacherArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    include: 'TeacherIncludeFromTeacher'


class FindManyTeacherArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    take: int
    skip: int
    order_by: Union['TeacherOrderByInput', List['TeacherOrderByInput']]
    where: 'TeacherWhereInput'
    cursor: 'TeacherWhereUniqueInput'
    distinct: List['TeacherScalarFieldKeys']
    include: 'TeacherIncludeFromTeacher'


class ClassModelIncludeFromParent(TypedDict, total=False):
    """Relational arguments for Parent"""
    teacher: Union[bool, 'TeacherArgsFromParent']
    students: Union[bool, 'FindManyStudentArgsFromParent']
    results: Union[bool, 'FindManyResultArgsFromParent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromParent']


class ClassModelArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    include: 'ClassModelIncludeFromClassModel'


class FindManyClassModelArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    take: int
    skip: int
    order_by: Union['ClassModelOrderByInput', List['ClassModelOrderByInput']]
    where: 'ClassModelWhereInput'
    cursor: 'ClassModelWhereUniqueInput'
    distinct: List['ClassModelScalarFieldKeys']
    include: 'ClassModelIncludeFromClassModel'


class StudentIncludeFromParent(TypedDict, total=False):
    """Relational arguments for Parent"""
    parent: Union[bool, 'ParentArgsFromParent']
    classModel: Union[bool, 'ClassModelArgsFromParent']
    results: Union[bool, 'FindManyResultArgsFromParent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromParent']


class StudentArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    include: 'StudentIncludeFromStudent'


class FindManyStudentArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudent'


class EventIncludeFromParent(TypedDict, total=False):
    """Relational arguments for Parent"""


class EventArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    include: 'EventIncludeFromEvent'


class FindManyEventArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEvent'


class MessageIncludeFromParent(TypedDict, total=False):
    """Relational arguments for Parent"""
    sender: Union[bool, 'UserArgsFromParent']
    recipient: Union[bool, 'UserArgsFromParent']


class MessageArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ResultIncludeFromParent(TypedDict, total=False):
    """Relational arguments for Parent"""
    student: Union[bool, 'StudentArgsFromParent']
    classModel: Union[bool, 'ClassModelArgsFromParent']
    teacher: Union[bool, 'TeacherArgsFromParent']


class ResultArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    include: 'ResultIncludeFromResult'


class FindManyResultArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    take: int
    skip: int
    order_by: Union['ResultOrderByInput', List['ResultOrderByInput']]
    where: 'ResultWhereInput'
    cursor: 'ResultWhereUniqueInput'
    distinct: List['ResultScalarFieldKeys']
    include: 'ResultIncludeFromResult'


class AttendanceIncludeFromParent(TypedDict, total=False):
    """Relational arguments for Parent"""
    student: Union[bool, 'StudentArgsFromParent']
    classModel: Union[bool, 'ClassModelArgsFromParent']
    teacher: Union[bool, 'TeacherArgsFromParent']


class AttendanceArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    include: 'AttendanceIncludeFromAttendance'


class FindManyAttendanceArgsFromParent(TypedDict, total=False):
    """Arguments for Parent"""
    take: int
    skip: int
    order_by: Union['AttendanceOrderByInput', List['AttendanceOrderByInput']]
    where: 'AttendanceWhereInput'
    cursor: 'AttendanceWhereUniqueInput'
    distinct: List['AttendanceScalarFieldKeys']
    include: 'AttendanceIncludeFromAttendance'




FindManyParentArgs = FindManyParentArgsFromParent
FindFirstParentArgs = FindManyParentArgsFromParent


class ParentWhereInput(TypedDict, total=False):
    """Parent arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    phone: Union[None, _str, 'types.StringFilter']
    profile_picture_url: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'
    students: 'StudentListRelationFilter'

    # should be noted that AND and NOT should be Union['ParentWhereInput', List['ParentWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ParentWhereInput']
    OR: List['ParentWhereInput']
    NOT: List['ParentWhereInput']



# aggregate Parent types


class ParentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Parent arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    profile_picture_url: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ParentScalarWhereWithAggregatesInput']
    OR: List['ParentScalarWhereWithAggregatesInput']
    NOT: List['ParentScalarWhereWithAggregatesInput']



class ParentGroupByOutput(TypedDict, total=False):
    id: _int
    user_id: _int
    phone: _str
    profile_picture_url: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'ParentSumAggregateOutput'
    _avg: 'ParentAvgAggregateOutput'
    _min: 'ParentMinAggregateOutput'
    _max: 'ParentMaxAggregateOutput'
    _count: 'ParentCountAggregateOutput'


class ParentAvgAggregateOutput(TypedDict, total=False):
    """Parent output for aggregating averages"""
    id: float
    user_id: float


class ParentSumAggregateOutput(TypedDict, total=False):
    """Parent output for aggregating sums"""
    id: _int
    user_id: _int


class ParentScalarAggregateOutput(TypedDict, total=False):
    """Parent output including scalar fields"""
    id: _int
    user_id: _int
    phone: _str
    profile_picture_url: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


ParentMinAggregateOutput = ParentScalarAggregateOutput
ParentMaxAggregateOutput = ParentScalarAggregateOutput


class ParentMaxAggregateInput(TypedDict, total=False):
    """Parent input for aggregating by max"""
    id: bool
    user_id: bool
    phone: bool
    profile_picture_url: bool
    created_at: bool
    updated_at: bool


class ParentMinAggregateInput(TypedDict, total=False):
    """Parent input for aggregating by min"""
    id: bool
    user_id: bool
    phone: bool
    profile_picture_url: bool
    created_at: bool
    updated_at: bool


class ParentNumberAggregateInput(TypedDict, total=False):
    """Parent input for aggregating numbers"""
    id: bool
    user_id: bool


ParentAvgAggregateInput = ParentNumberAggregateInput
ParentSumAggregateInput = ParentNumberAggregateInput


ParentCountAggregateInput = TypedDict(
    'ParentCountAggregateInput',
    {
        'id': bool,
        'user_id': bool,
        'phone': bool,
        'profile_picture_url': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

ParentCountAggregateOutput = TypedDict(
    'ParentCountAggregateOutput',
    {
        'id': int,
        'user_id': int,
        'phone': int,
        'profile_picture_url': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


ParentKeys = Literal[
    'id',
    'user_id',
    'phone',
    'profile_picture_url',
    'created_at',
    'updated_at',
    'user',
    'students',
]
ParentScalarFieldKeys = Literal[
    'id',
    'user_id',
    'phone',
    'profile_picture_url',
    'created_at',
    'updated_at',
]
ParentScalarFieldKeysT = TypeVar('ParentScalarFieldKeysT', bound=ParentScalarFieldKeys)

ParentRelationalFieldKeys = Literal[
        'user',
        'students',
    ]

# Teacher types

class TeacherOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Teacher create method"""
    id: _int
    user_id: _int
    phone: Optional[_str]
    subjects: Optional[_str]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'
    classes: 'ClassModelCreateManyNestedWithoutRelationsInput'
    results: 'ResultCreateManyNestedWithoutRelationsInput'
    attendance: 'AttendanceCreateManyNestedWithoutRelationsInput'


class TeacherCreateInput(TeacherOptionalCreateInput):
    """Required arguments to the Teacher create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TeacherOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Teacher create method, without relations"""
    id: _int
    user_id: _int
    phone: Optional[_str]
    subjects: Optional[_str]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class TeacherCreateWithoutRelationsInput(TeacherOptionalCreateWithoutRelationsInput):
    """Required arguments to the Teacher create method, without relations"""

class TeacherConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TeacherCreateWithoutRelationsInput'
    where: 'TeacherWhereUniqueInput'

class TeacherCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TeacherCreateWithoutRelationsInput'
    connect: 'TeacherWhereUniqueInput'
    connect_or_create: 'TeacherConnectOrCreateWithoutRelationsInput'


class TeacherCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TeacherCreateWithoutRelationsInput', List['TeacherCreateWithoutRelationsInput']]
    connect: Union['TeacherWhereUniqueInput', List['TeacherWhereUniqueInput']]
    connect_or_create: Union['TeacherConnectOrCreateWithoutRelationsInput', List['TeacherConnectOrCreateWithoutRelationsInput']]

_TeacherWhereUnique_id_Input = TypedDict(
    '_TeacherWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_TeacherWhereUnique_user_id_Input = TypedDict(
    '_TeacherWhereUnique_user_id_Input',
    {
        'user_id': '_int',
    },
    total=True
)

TeacherWhereUniqueInput = Union[
    '_TeacherWhereUnique_id_Input',
    '_TeacherWhereUnique_user_id_Input',
]


class TeacherUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    phone: Optional[_str]
    subjects: Optional[_str]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    classes: 'ClassModelUpdateManyWithoutRelationsInput'
    results: 'ResultUpdateManyWithoutRelationsInput'
    attendance: 'AttendanceUpdateManyWithoutRelationsInput'


class TeacherUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    phone: Optional[_str]
    subjects: Optional[_str]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class TeacherUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TeacherCreateWithoutRelationsInput']
    connect: List['TeacherWhereUniqueInput']
    connect_or_create: List['TeacherConnectOrCreateWithoutRelationsInput']
    set: List['TeacherWhereUniqueInput']
    disconnect: List['TeacherWhereUniqueInput']
    delete: List['TeacherWhereUniqueInput']

    # TODO
    # update: List['TeacherUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TeacherUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TeacherScalarWhereInput']
    # upsert: List['TeacherUpserteWithWhereUniqueWithoutRelationsInput']


class TeacherUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TeacherCreateWithoutRelationsInput'
    connect: 'TeacherWhereUniqueInput'
    connect_or_create: 'TeacherConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TeacherUpdateInput'
    # upsert: 'TeacherUpsertWithoutRelationsInput'


class TeacherUpsertInput(TypedDict):
    create: 'TeacherCreateInput'
    update: 'TeacherUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Teacher_id_OrderByInput = TypedDict(
    '_Teacher_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Teacher_user_id_OrderByInput = TypedDict(
    '_Teacher_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_Teacher_phone_OrderByInput = TypedDict(
    '_Teacher_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Teacher_subjects_OrderByInput = TypedDict(
    '_Teacher_subjects_OrderByInput',
    {
        'subjects': 'SortOrder',
    },
    total=True
)

_Teacher_status_OrderByInput = TypedDict(
    '_Teacher_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Teacher_created_at_OrderByInput = TypedDict(
    '_Teacher_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Teacher_updated_at_OrderByInput = TypedDict(
    '_Teacher_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

TeacherOrderByInput = Union[
    '_Teacher_id_OrderByInput',
    '_Teacher_user_id_OrderByInput',
    '_Teacher_phone_OrderByInput',
    '_Teacher_subjects_OrderByInput',
    '_Teacher_status_OrderByInput',
    '_Teacher_created_at_OrderByInput',
    '_Teacher_updated_at_OrderByInput',
]



# recursive Teacher types
# TODO: cleanup these types



TeacherRelationFilter = TypedDict(
    'TeacherRelationFilter',
    {
        'is': 'TeacherWhereInput',
        'is_not': 'TeacherWhereInput',
    },
    total=False,
)


class TeacherListRelationFilter(TypedDict, total=False):
    some: 'TeacherWhereInput'
    none: 'TeacherWhereInput'
    every: 'TeacherWhereInput'


class TeacherInclude(TypedDict, total=False):
    """Teacher relational arguments"""
    user: Union[bool, 'UserArgsFromTeacher']
    classes: Union[bool, 'FindManyClassModelArgsFromTeacher']
    results: Union[bool, 'FindManyResultArgsFromTeacher']
    attendance: Union[bool, 'FindManyAttendanceArgsFromTeacher']


class UserIncludeFromTeacher(TypedDict, total=False):
    """Relational arguments for Teacher"""
    parent: Union[bool, 'ParentArgsFromTeacher']
    teacher: Union[bool, 'TeacherArgsFromTeacher']
    sentMessages: Union[bool, 'FindManyMessageArgsFromTeacher']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromTeacher']


class UserArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class ParentIncludeFromTeacher(TypedDict, total=False):
    """Relational arguments for Teacher"""
    user: Union[bool, 'UserArgsFromTeacher']
    students: Union[bool, 'FindManyStudentArgsFromTeacher']


class ParentArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    include: 'ParentIncludeFromParent'


class FindManyParentArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    take: int
    skip: int
    order_by: Union['ParentOrderByInput', List['ParentOrderByInput']]
    where: 'ParentWhereInput'
    cursor: 'ParentWhereUniqueInput'
    distinct: List['ParentScalarFieldKeys']
    include: 'ParentIncludeFromParent'


class TeacherIncludeFromTeacher(TypedDict, total=False):
    """Relational arguments for Teacher"""
    user: Union[bool, 'UserArgsFromTeacher']
    classes: Union[bool, 'FindManyClassModelArgsFromTeacher']
    results: Union[bool, 'FindManyResultArgsFromTeacher']
    attendance: Union[bool, 'FindManyAttendanceArgsFromTeacher']


class TeacherArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    include: 'TeacherIncludeFromTeacher'


class FindManyTeacherArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    take: int
    skip: int
    order_by: Union['TeacherOrderByInput', List['TeacherOrderByInput']]
    where: 'TeacherWhereInput'
    cursor: 'TeacherWhereUniqueInput'
    distinct: List['TeacherScalarFieldKeys']
    include: 'TeacherIncludeFromTeacher'


class ClassModelIncludeFromTeacher(TypedDict, total=False):
    """Relational arguments for Teacher"""
    teacher: Union[bool, 'TeacherArgsFromTeacher']
    students: Union[bool, 'FindManyStudentArgsFromTeacher']
    results: Union[bool, 'FindManyResultArgsFromTeacher']
    attendance: Union[bool, 'FindManyAttendanceArgsFromTeacher']


class ClassModelArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    include: 'ClassModelIncludeFromClassModel'


class FindManyClassModelArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    take: int
    skip: int
    order_by: Union['ClassModelOrderByInput', List['ClassModelOrderByInput']]
    where: 'ClassModelWhereInput'
    cursor: 'ClassModelWhereUniqueInput'
    distinct: List['ClassModelScalarFieldKeys']
    include: 'ClassModelIncludeFromClassModel'


class StudentIncludeFromTeacher(TypedDict, total=False):
    """Relational arguments for Teacher"""
    parent: Union[bool, 'ParentArgsFromTeacher']
    classModel: Union[bool, 'ClassModelArgsFromTeacher']
    results: Union[bool, 'FindManyResultArgsFromTeacher']
    attendance: Union[bool, 'FindManyAttendanceArgsFromTeacher']


class StudentArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    include: 'StudentIncludeFromStudent'


class FindManyStudentArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudent'


class EventIncludeFromTeacher(TypedDict, total=False):
    """Relational arguments for Teacher"""


class EventArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    include: 'EventIncludeFromEvent'


class FindManyEventArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEvent'


class MessageIncludeFromTeacher(TypedDict, total=False):
    """Relational arguments for Teacher"""
    sender: Union[bool, 'UserArgsFromTeacher']
    recipient: Union[bool, 'UserArgsFromTeacher']


class MessageArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ResultIncludeFromTeacher(TypedDict, total=False):
    """Relational arguments for Teacher"""
    student: Union[bool, 'StudentArgsFromTeacher']
    classModel: Union[bool, 'ClassModelArgsFromTeacher']
    teacher: Union[bool, 'TeacherArgsFromTeacher']


class ResultArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    include: 'ResultIncludeFromResult'


class FindManyResultArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    take: int
    skip: int
    order_by: Union['ResultOrderByInput', List['ResultOrderByInput']]
    where: 'ResultWhereInput'
    cursor: 'ResultWhereUniqueInput'
    distinct: List['ResultScalarFieldKeys']
    include: 'ResultIncludeFromResult'


class AttendanceIncludeFromTeacher(TypedDict, total=False):
    """Relational arguments for Teacher"""
    student: Union[bool, 'StudentArgsFromTeacher']
    classModel: Union[bool, 'ClassModelArgsFromTeacher']
    teacher: Union[bool, 'TeacherArgsFromTeacher']


class AttendanceArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    include: 'AttendanceIncludeFromAttendance'


class FindManyAttendanceArgsFromTeacher(TypedDict, total=False):
    """Arguments for Teacher"""
    take: int
    skip: int
    order_by: Union['AttendanceOrderByInput', List['AttendanceOrderByInput']]
    where: 'AttendanceWhereInput'
    cursor: 'AttendanceWhereUniqueInput'
    distinct: List['AttendanceScalarFieldKeys']
    include: 'AttendanceIncludeFromAttendance'




FindManyTeacherArgs = FindManyTeacherArgsFromTeacher
FindFirstTeacherArgs = FindManyTeacherArgsFromTeacher


class TeacherWhereInput(TypedDict, total=False):
    """Teacher arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    phone: Union[None, _str, 'types.StringFilter']
    subjects: Union[None, _str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'
    classes: 'ClassModelListRelationFilter'
    results: 'ResultListRelationFilter'
    attendance: 'AttendanceListRelationFilter'

    # should be noted that AND and NOT should be Union['TeacherWhereInput', List['TeacherWhereInput']]
    # but this causes mypy to hang :/
    AND: List['TeacherWhereInput']
    OR: List['TeacherWhereInput']
    NOT: List['TeacherWhereInput']



# aggregate Teacher types


class TeacherScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Teacher arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    subjects: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TeacherScalarWhereWithAggregatesInput']
    OR: List['TeacherScalarWhereWithAggregatesInput']
    NOT: List['TeacherScalarWhereWithAggregatesInput']



class TeacherGroupByOutput(TypedDict, total=False):
    id: _int
    user_id: _int
    phone: _str
    subjects: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'TeacherSumAggregateOutput'
    _avg: 'TeacherAvgAggregateOutput'
    _min: 'TeacherMinAggregateOutput'
    _max: 'TeacherMaxAggregateOutput'
    _count: 'TeacherCountAggregateOutput'


class TeacherAvgAggregateOutput(TypedDict, total=False):
    """Teacher output for aggregating averages"""
    id: float
    user_id: float


class TeacherSumAggregateOutput(TypedDict, total=False):
    """Teacher output for aggregating sums"""
    id: _int
    user_id: _int


class TeacherScalarAggregateOutput(TypedDict, total=False):
    """Teacher output including scalar fields"""
    id: _int
    user_id: _int
    phone: _str
    subjects: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


TeacherMinAggregateOutput = TeacherScalarAggregateOutput
TeacherMaxAggregateOutput = TeacherScalarAggregateOutput


class TeacherMaxAggregateInput(TypedDict, total=False):
    """Teacher input for aggregating by max"""
    id: bool
    user_id: bool
    phone: bool
    subjects: bool
    status: bool
    created_at: bool
    updated_at: bool


class TeacherMinAggregateInput(TypedDict, total=False):
    """Teacher input for aggregating by min"""
    id: bool
    user_id: bool
    phone: bool
    subjects: bool
    status: bool
    created_at: bool
    updated_at: bool


class TeacherNumberAggregateInput(TypedDict, total=False):
    """Teacher input for aggregating numbers"""
    id: bool
    user_id: bool


TeacherAvgAggregateInput = TeacherNumberAggregateInput
TeacherSumAggregateInput = TeacherNumberAggregateInput


TeacherCountAggregateInput = TypedDict(
    'TeacherCountAggregateInput',
    {
        'id': bool,
        'user_id': bool,
        'phone': bool,
        'subjects': bool,
        'status': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

TeacherCountAggregateOutput = TypedDict(
    'TeacherCountAggregateOutput',
    {
        'id': int,
        'user_id': int,
        'phone': int,
        'subjects': int,
        'status': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


TeacherKeys = Literal[
    'id',
    'user_id',
    'phone',
    'subjects',
    'status',
    'created_at',
    'updated_at',
    'user',
    'classes',
    'results',
    'attendance',
]
TeacherScalarFieldKeys = Literal[
    'id',
    'user_id',
    'phone',
    'subjects',
    'status',
    'created_at',
    'updated_at',
]
TeacherScalarFieldKeysT = TypeVar('TeacherScalarFieldKeysT', bound=TeacherScalarFieldKeys)

TeacherRelationalFieldKeys = Literal[
        'user',
        'classes',
        'results',
        'attendance',
    ]

# ClassModel types

class ClassModelOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ClassModel create method"""
    id: _int
    teacher_id: Optional[_int]
    room: Optional[_str]
    subjects: Optional[_str]
    expected_students: _int
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    teacher: 'TeacherCreateNestedWithoutRelationsInput'
    students: 'StudentCreateManyNestedWithoutRelationsInput'
    results: 'ResultCreateManyNestedWithoutRelationsInput'
    attendance: 'AttendanceCreateManyNestedWithoutRelationsInput'


class ClassModelCreateInput(ClassModelOptionalCreateInput):
    """Required arguments to the ClassModel create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ClassModelOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ClassModel create method, without relations"""
    id: _int
    teacher_id: Optional[_int]
    room: Optional[_str]
    subjects: Optional[_str]
    expected_students: _int
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class ClassModelCreateWithoutRelationsInput(ClassModelOptionalCreateWithoutRelationsInput):
    """Required arguments to the ClassModel create method, without relations"""
    name: _str

class ClassModelConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ClassModelCreateWithoutRelationsInput'
    where: 'ClassModelWhereUniqueInput'

class ClassModelCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ClassModelCreateWithoutRelationsInput'
    connect: 'ClassModelWhereUniqueInput'
    connect_or_create: 'ClassModelConnectOrCreateWithoutRelationsInput'


class ClassModelCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ClassModelCreateWithoutRelationsInput', List['ClassModelCreateWithoutRelationsInput']]
    connect: Union['ClassModelWhereUniqueInput', List['ClassModelWhereUniqueInput']]
    connect_or_create: Union['ClassModelConnectOrCreateWithoutRelationsInput', List['ClassModelConnectOrCreateWithoutRelationsInput']]

_ClassModelWhereUnique_id_Input = TypedDict(
    '_ClassModelWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_ClassModelWhereUnique_name_Input = TypedDict(
    '_ClassModelWhereUnique_name_Input',
    {
        'name': '_str',
    },
    total=True
)

ClassModelWhereUniqueInput = Union[
    '_ClassModelWhereUnique_id_Input',
    '_ClassModelWhereUnique_name_Input',
]


class ClassModelUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    room: Optional[_str]
    subjects: Optional[_str]
    expected_students: Union[AtomicIntInput, _int]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    teacher: 'TeacherUpdateOneWithoutRelationsInput'
    students: 'StudentUpdateManyWithoutRelationsInput'
    results: 'ResultUpdateManyWithoutRelationsInput'
    attendance: 'AttendanceUpdateManyWithoutRelationsInput'


class ClassModelUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    room: Optional[_str]
    subjects: Optional[_str]
    expected_students: Union[AtomicIntInput, _int]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class ClassModelUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ClassModelCreateWithoutRelationsInput']
    connect: List['ClassModelWhereUniqueInput']
    connect_or_create: List['ClassModelConnectOrCreateWithoutRelationsInput']
    set: List['ClassModelWhereUniqueInput']
    disconnect: List['ClassModelWhereUniqueInput']
    delete: List['ClassModelWhereUniqueInput']

    # TODO
    # update: List['ClassModelUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ClassModelUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ClassModelScalarWhereInput']
    # upsert: List['ClassModelUpserteWithWhereUniqueWithoutRelationsInput']


class ClassModelUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ClassModelCreateWithoutRelationsInput'
    connect: 'ClassModelWhereUniqueInput'
    connect_or_create: 'ClassModelConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ClassModelUpdateInput'
    # upsert: 'ClassModelUpsertWithoutRelationsInput'


class ClassModelUpsertInput(TypedDict):
    create: 'ClassModelCreateInput'
    update: 'ClassModelUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ClassModel_id_OrderByInput = TypedDict(
    '_ClassModel_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ClassModel_name_OrderByInput = TypedDict(
    '_ClassModel_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_ClassModel_teacher_id_OrderByInput = TypedDict(
    '_ClassModel_teacher_id_OrderByInput',
    {
        'teacher_id': 'SortOrder',
    },
    total=True
)

_ClassModel_room_OrderByInput = TypedDict(
    '_ClassModel_room_OrderByInput',
    {
        'room': 'SortOrder',
    },
    total=True
)

_ClassModel_subjects_OrderByInput = TypedDict(
    '_ClassModel_subjects_OrderByInput',
    {
        'subjects': 'SortOrder',
    },
    total=True
)

_ClassModel_expected_students_OrderByInput = TypedDict(
    '_ClassModel_expected_students_OrderByInput',
    {
        'expected_students': 'SortOrder',
    },
    total=True
)

_ClassModel_status_OrderByInput = TypedDict(
    '_ClassModel_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_ClassModel_created_at_OrderByInput = TypedDict(
    '_ClassModel_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_ClassModel_updated_at_OrderByInput = TypedDict(
    '_ClassModel_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

ClassModelOrderByInput = Union[
    '_ClassModel_id_OrderByInput',
    '_ClassModel_name_OrderByInput',
    '_ClassModel_teacher_id_OrderByInput',
    '_ClassModel_room_OrderByInput',
    '_ClassModel_subjects_OrderByInput',
    '_ClassModel_expected_students_OrderByInput',
    '_ClassModel_status_OrderByInput',
    '_ClassModel_created_at_OrderByInput',
    '_ClassModel_updated_at_OrderByInput',
]



# recursive ClassModel types
# TODO: cleanup these types



ClassModelRelationFilter = TypedDict(
    'ClassModelRelationFilter',
    {
        'is': 'ClassModelWhereInput',
        'is_not': 'ClassModelWhereInput',
    },
    total=False,
)


class ClassModelListRelationFilter(TypedDict, total=False):
    some: 'ClassModelWhereInput'
    none: 'ClassModelWhereInput'
    every: 'ClassModelWhereInput'


class ClassModelInclude(TypedDict, total=False):
    """ClassModel relational arguments"""
    teacher: Union[bool, 'TeacherArgsFromClassModel']
    students: Union[bool, 'FindManyStudentArgsFromClassModel']
    results: Union[bool, 'FindManyResultArgsFromClassModel']
    attendance: Union[bool, 'FindManyAttendanceArgsFromClassModel']


class UserIncludeFromClassModel(TypedDict, total=False):
    """Relational arguments for ClassModel"""
    parent: Union[bool, 'ParentArgsFromClassModel']
    teacher: Union[bool, 'TeacherArgsFromClassModel']
    sentMessages: Union[bool, 'FindManyMessageArgsFromClassModel']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromClassModel']


class UserArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class ParentIncludeFromClassModel(TypedDict, total=False):
    """Relational arguments for ClassModel"""
    user: Union[bool, 'UserArgsFromClassModel']
    students: Union[bool, 'FindManyStudentArgsFromClassModel']


class ParentArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    include: 'ParentIncludeFromParent'


class FindManyParentArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    take: int
    skip: int
    order_by: Union['ParentOrderByInput', List['ParentOrderByInput']]
    where: 'ParentWhereInput'
    cursor: 'ParentWhereUniqueInput'
    distinct: List['ParentScalarFieldKeys']
    include: 'ParentIncludeFromParent'


class TeacherIncludeFromClassModel(TypedDict, total=False):
    """Relational arguments for ClassModel"""
    user: Union[bool, 'UserArgsFromClassModel']
    classes: Union[bool, 'FindManyClassModelArgsFromClassModel']
    results: Union[bool, 'FindManyResultArgsFromClassModel']
    attendance: Union[bool, 'FindManyAttendanceArgsFromClassModel']


class TeacherArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    include: 'TeacherIncludeFromTeacher'


class FindManyTeacherArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    take: int
    skip: int
    order_by: Union['TeacherOrderByInput', List['TeacherOrderByInput']]
    where: 'TeacherWhereInput'
    cursor: 'TeacherWhereUniqueInput'
    distinct: List['TeacherScalarFieldKeys']
    include: 'TeacherIncludeFromTeacher'


class ClassModelIncludeFromClassModel(TypedDict, total=False):
    """Relational arguments for ClassModel"""
    teacher: Union[bool, 'TeacherArgsFromClassModel']
    students: Union[bool, 'FindManyStudentArgsFromClassModel']
    results: Union[bool, 'FindManyResultArgsFromClassModel']
    attendance: Union[bool, 'FindManyAttendanceArgsFromClassModel']


class ClassModelArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    include: 'ClassModelIncludeFromClassModel'


class FindManyClassModelArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    take: int
    skip: int
    order_by: Union['ClassModelOrderByInput', List['ClassModelOrderByInput']]
    where: 'ClassModelWhereInput'
    cursor: 'ClassModelWhereUniqueInput'
    distinct: List['ClassModelScalarFieldKeys']
    include: 'ClassModelIncludeFromClassModel'


class StudentIncludeFromClassModel(TypedDict, total=False):
    """Relational arguments for ClassModel"""
    parent: Union[bool, 'ParentArgsFromClassModel']
    classModel: Union[bool, 'ClassModelArgsFromClassModel']
    results: Union[bool, 'FindManyResultArgsFromClassModel']
    attendance: Union[bool, 'FindManyAttendanceArgsFromClassModel']


class StudentArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    include: 'StudentIncludeFromStudent'


class FindManyStudentArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudent'


class EventIncludeFromClassModel(TypedDict, total=False):
    """Relational arguments for ClassModel"""


class EventArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    include: 'EventIncludeFromEvent'


class FindManyEventArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEvent'


class MessageIncludeFromClassModel(TypedDict, total=False):
    """Relational arguments for ClassModel"""
    sender: Union[bool, 'UserArgsFromClassModel']
    recipient: Union[bool, 'UserArgsFromClassModel']


class MessageArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ResultIncludeFromClassModel(TypedDict, total=False):
    """Relational arguments for ClassModel"""
    student: Union[bool, 'StudentArgsFromClassModel']
    classModel: Union[bool, 'ClassModelArgsFromClassModel']
    teacher: Union[bool, 'TeacherArgsFromClassModel']


class ResultArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    include: 'ResultIncludeFromResult'


class FindManyResultArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    take: int
    skip: int
    order_by: Union['ResultOrderByInput', List['ResultOrderByInput']]
    where: 'ResultWhereInput'
    cursor: 'ResultWhereUniqueInput'
    distinct: List['ResultScalarFieldKeys']
    include: 'ResultIncludeFromResult'


class AttendanceIncludeFromClassModel(TypedDict, total=False):
    """Relational arguments for ClassModel"""
    student: Union[bool, 'StudentArgsFromClassModel']
    classModel: Union[bool, 'ClassModelArgsFromClassModel']
    teacher: Union[bool, 'TeacherArgsFromClassModel']


class AttendanceArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    include: 'AttendanceIncludeFromAttendance'


class FindManyAttendanceArgsFromClassModel(TypedDict, total=False):
    """Arguments for ClassModel"""
    take: int
    skip: int
    order_by: Union['AttendanceOrderByInput', List['AttendanceOrderByInput']]
    where: 'AttendanceWhereInput'
    cursor: 'AttendanceWhereUniqueInput'
    distinct: List['AttendanceScalarFieldKeys']
    include: 'AttendanceIncludeFromAttendance'




FindManyClassModelArgs = FindManyClassModelArgsFromClassModel
FindFirstClassModelArgs = FindManyClassModelArgsFromClassModel


class ClassModelWhereInput(TypedDict, total=False):
    """ClassModel arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    teacher_id: Union[None, _int, 'types.IntFilter']
    room: Union[None, _str, 'types.StringFilter']
    subjects: Union[None, _str, 'types.StringFilter']
    expected_students: Union[_int, 'types.IntFilter']
    status: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    teacher: 'TeacherRelationFilter'
    students: 'StudentListRelationFilter'
    results: 'ResultListRelationFilter'
    attendance: 'AttendanceListRelationFilter'

    # should be noted that AND and NOT should be Union['ClassModelWhereInput', List['ClassModelWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ClassModelWhereInput']
    OR: List['ClassModelWhereInput']
    NOT: List['ClassModelWhereInput']



# aggregate ClassModel types


class ClassModelScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ClassModel arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    teacher_id: Union[_int, 'types.IntWithAggregatesFilter']
    room: Union[_str, 'types.StringWithAggregatesFilter']
    subjects: Union[_str, 'types.StringWithAggregatesFilter']
    expected_students: Union[_int, 'types.IntWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ClassModelScalarWhereWithAggregatesInput']
    OR: List['ClassModelScalarWhereWithAggregatesInput']
    NOT: List['ClassModelScalarWhereWithAggregatesInput']



class ClassModelGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    teacher_id: _int
    room: _str
    subjects: _str
    expected_students: _int
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'ClassModelSumAggregateOutput'
    _avg: 'ClassModelAvgAggregateOutput'
    _min: 'ClassModelMinAggregateOutput'
    _max: 'ClassModelMaxAggregateOutput'
    _count: 'ClassModelCountAggregateOutput'


class ClassModelAvgAggregateOutput(TypedDict, total=False):
    """ClassModel output for aggregating averages"""
    id: float
    teacher_id: float
    expected_students: float


class ClassModelSumAggregateOutput(TypedDict, total=False):
    """ClassModel output for aggregating sums"""
    id: _int
    teacher_id: _int
    expected_students: _int


class ClassModelScalarAggregateOutput(TypedDict, total=False):
    """ClassModel output including scalar fields"""
    id: _int
    name: _str
    teacher_id: _int
    room: _str
    subjects: _str
    expected_students: _int
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


ClassModelMinAggregateOutput = ClassModelScalarAggregateOutput
ClassModelMaxAggregateOutput = ClassModelScalarAggregateOutput


class ClassModelMaxAggregateInput(TypedDict, total=False):
    """ClassModel input for aggregating by max"""
    id: bool
    name: bool
    teacher_id: bool
    room: bool
    subjects: bool
    expected_students: bool
    status: bool
    created_at: bool
    updated_at: bool


class ClassModelMinAggregateInput(TypedDict, total=False):
    """ClassModel input for aggregating by min"""
    id: bool
    name: bool
    teacher_id: bool
    room: bool
    subjects: bool
    expected_students: bool
    status: bool
    created_at: bool
    updated_at: bool


class ClassModelNumberAggregateInput(TypedDict, total=False):
    """ClassModel input for aggregating numbers"""
    id: bool
    teacher_id: bool
    expected_students: bool


ClassModelAvgAggregateInput = ClassModelNumberAggregateInput
ClassModelSumAggregateInput = ClassModelNumberAggregateInput


ClassModelCountAggregateInput = TypedDict(
    'ClassModelCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'teacher_id': bool,
        'room': bool,
        'subjects': bool,
        'expected_students': bool,
        'status': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

ClassModelCountAggregateOutput = TypedDict(
    'ClassModelCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'teacher_id': int,
        'room': int,
        'subjects': int,
        'expected_students': int,
        'status': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


ClassModelKeys = Literal[
    'id',
    'name',
    'teacher_id',
    'room',
    'subjects',
    'expected_students',
    'status',
    'created_at',
    'updated_at',
    'teacher',
    'students',
    'results',
    'attendance',
]
ClassModelScalarFieldKeys = Literal[
    'id',
    'name',
    'teacher_id',
    'room',
    'subjects',
    'expected_students',
    'status',
    'created_at',
    'updated_at',
]
ClassModelScalarFieldKeysT = TypeVar('ClassModelScalarFieldKeysT', bound=ClassModelScalarFieldKeys)

ClassModelRelationalFieldKeys = Literal[
        'teacher',
        'students',
        'results',
        'attendance',
    ]

# Student types

class StudentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Student create method"""
    id: _int
    class_id: Optional[_int]
    roll_no: Optional[_str]
    parent_id: Optional[_int]
    email: Optional[_str]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    parent: 'ParentCreateNestedWithoutRelationsInput'
    classModel: 'ClassModelCreateNestedWithoutRelationsInput'
    results: 'ResultCreateManyNestedWithoutRelationsInput'
    attendance: 'AttendanceCreateManyNestedWithoutRelationsInput'


class StudentCreateInput(StudentOptionalCreateInput):
    """Required arguments to the Student create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class StudentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Student create method, without relations"""
    id: _int
    class_id: Optional[_int]
    roll_no: Optional[_str]
    parent_id: Optional[_int]
    email: Optional[_str]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class StudentCreateWithoutRelationsInput(StudentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Student create method, without relations"""
    name: _str

class StudentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'StudentCreateWithoutRelationsInput'
    where: 'StudentWhereUniqueInput'

class StudentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'StudentCreateWithoutRelationsInput'
    connect: 'StudentWhereUniqueInput'
    connect_or_create: 'StudentConnectOrCreateWithoutRelationsInput'


class StudentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['StudentCreateWithoutRelationsInput', List['StudentCreateWithoutRelationsInput']]
    connect: Union['StudentWhereUniqueInput', List['StudentWhereUniqueInput']]
    connect_or_create: Union['StudentConnectOrCreateWithoutRelationsInput', List['StudentConnectOrCreateWithoutRelationsInput']]

_StudentWhereUnique_id_Input = TypedDict(
    '_StudentWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_StudentWhereUnique_roll_no_Input = TypedDict(
    '_StudentWhereUnique_roll_no_Input',
    {
        'roll_no': '_str',
    },
    total=True
)

_StudentWhereUnique_email_Input = TypedDict(
    '_StudentWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

StudentWhereUniqueInput = Union[
    '_StudentWhereUnique_id_Input',
    '_StudentWhereUnique_roll_no_Input',
    '_StudentWhereUnique_email_Input',
]


class StudentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    roll_no: Optional[_str]
    email: Optional[_str]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    parent: 'ParentUpdateOneWithoutRelationsInput'
    classModel: 'ClassModelUpdateOneWithoutRelationsInput'
    results: 'ResultUpdateManyWithoutRelationsInput'
    attendance: 'AttendanceUpdateManyWithoutRelationsInput'


class StudentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    roll_no: Optional[_str]
    email: Optional[_str]
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class StudentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['StudentCreateWithoutRelationsInput']
    connect: List['StudentWhereUniqueInput']
    connect_or_create: List['StudentConnectOrCreateWithoutRelationsInput']
    set: List['StudentWhereUniqueInput']
    disconnect: List['StudentWhereUniqueInput']
    delete: List['StudentWhereUniqueInput']

    # TODO
    # update: List['StudentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['StudentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['StudentScalarWhereInput']
    # upsert: List['StudentUpserteWithWhereUniqueWithoutRelationsInput']


class StudentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'StudentCreateWithoutRelationsInput'
    connect: 'StudentWhereUniqueInput'
    connect_or_create: 'StudentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'StudentUpdateInput'
    # upsert: 'StudentUpsertWithoutRelationsInput'


class StudentUpsertInput(TypedDict):
    create: 'StudentCreateInput'
    update: 'StudentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Student_id_OrderByInput = TypedDict(
    '_Student_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Student_name_OrderByInput = TypedDict(
    '_Student_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Student_class_id_OrderByInput = TypedDict(
    '_Student_class_id_OrderByInput',
    {
        'class_id': 'SortOrder',
    },
    total=True
)

_Student_roll_no_OrderByInput = TypedDict(
    '_Student_roll_no_OrderByInput',
    {
        'roll_no': 'SortOrder',
    },
    total=True
)

_Student_parent_id_OrderByInput = TypedDict(
    '_Student_parent_id_OrderByInput',
    {
        'parent_id': 'SortOrder',
    },
    total=True
)

_Student_email_OrderByInput = TypedDict(
    '_Student_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Student_status_OrderByInput = TypedDict(
    '_Student_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Student_created_at_OrderByInput = TypedDict(
    '_Student_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Student_updated_at_OrderByInput = TypedDict(
    '_Student_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

StudentOrderByInput = Union[
    '_Student_id_OrderByInput',
    '_Student_name_OrderByInput',
    '_Student_class_id_OrderByInput',
    '_Student_roll_no_OrderByInput',
    '_Student_parent_id_OrderByInput',
    '_Student_email_OrderByInput',
    '_Student_status_OrderByInput',
    '_Student_created_at_OrderByInput',
    '_Student_updated_at_OrderByInput',
]



# recursive Student types
# TODO: cleanup these types



StudentRelationFilter = TypedDict(
    'StudentRelationFilter',
    {
        'is': 'StudentWhereInput',
        'is_not': 'StudentWhereInput',
    },
    total=False,
)


class StudentListRelationFilter(TypedDict, total=False):
    some: 'StudentWhereInput'
    none: 'StudentWhereInput'
    every: 'StudentWhereInput'


class StudentInclude(TypedDict, total=False):
    """Student relational arguments"""
    parent: Union[bool, 'ParentArgsFromStudent']
    classModel: Union[bool, 'ClassModelArgsFromStudent']
    results: Union[bool, 'FindManyResultArgsFromStudent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromStudent']


class UserIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    parent: Union[bool, 'ParentArgsFromStudent']
    teacher: Union[bool, 'TeacherArgsFromStudent']
    sentMessages: Union[bool, 'FindManyMessageArgsFromStudent']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromStudent']


class UserArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class ParentIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    user: Union[bool, 'UserArgsFromStudent']
    students: Union[bool, 'FindManyStudentArgsFromStudent']


class ParentArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'ParentIncludeFromParent'


class FindManyParentArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['ParentOrderByInput', List['ParentOrderByInput']]
    where: 'ParentWhereInput'
    cursor: 'ParentWhereUniqueInput'
    distinct: List['ParentScalarFieldKeys']
    include: 'ParentIncludeFromParent'


class TeacherIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    user: Union[bool, 'UserArgsFromStudent']
    classes: Union[bool, 'FindManyClassModelArgsFromStudent']
    results: Union[bool, 'FindManyResultArgsFromStudent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromStudent']


class TeacherArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'TeacherIncludeFromTeacher'


class FindManyTeacherArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['TeacherOrderByInput', List['TeacherOrderByInput']]
    where: 'TeacherWhereInput'
    cursor: 'TeacherWhereUniqueInput'
    distinct: List['TeacherScalarFieldKeys']
    include: 'TeacherIncludeFromTeacher'


class ClassModelIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    teacher: Union[bool, 'TeacherArgsFromStudent']
    students: Union[bool, 'FindManyStudentArgsFromStudent']
    results: Union[bool, 'FindManyResultArgsFromStudent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromStudent']


class ClassModelArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'ClassModelIncludeFromClassModel'


class FindManyClassModelArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['ClassModelOrderByInput', List['ClassModelOrderByInput']]
    where: 'ClassModelWhereInput'
    cursor: 'ClassModelWhereUniqueInput'
    distinct: List['ClassModelScalarFieldKeys']
    include: 'ClassModelIncludeFromClassModel'


class StudentIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    parent: Union[bool, 'ParentArgsFromStudent']
    classModel: Union[bool, 'ClassModelArgsFromStudent']
    results: Union[bool, 'FindManyResultArgsFromStudent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromStudent']


class StudentArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'StudentIncludeFromStudent'


class FindManyStudentArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudent'


class EventIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""


class EventArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'EventIncludeFromEvent'


class FindManyEventArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEvent'


class MessageIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    sender: Union[bool, 'UserArgsFromStudent']
    recipient: Union[bool, 'UserArgsFromStudent']


class MessageArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ResultIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    student: Union[bool, 'StudentArgsFromStudent']
    classModel: Union[bool, 'ClassModelArgsFromStudent']
    teacher: Union[bool, 'TeacherArgsFromStudent']


class ResultArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'ResultIncludeFromResult'


class FindManyResultArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['ResultOrderByInput', List['ResultOrderByInput']]
    where: 'ResultWhereInput'
    cursor: 'ResultWhereUniqueInput'
    distinct: List['ResultScalarFieldKeys']
    include: 'ResultIncludeFromResult'


class AttendanceIncludeFromStudent(TypedDict, total=False):
    """Relational arguments for Student"""
    student: Union[bool, 'StudentArgsFromStudent']
    classModel: Union[bool, 'ClassModelArgsFromStudent']
    teacher: Union[bool, 'TeacherArgsFromStudent']


class AttendanceArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    include: 'AttendanceIncludeFromAttendance'


class FindManyAttendanceArgsFromStudent(TypedDict, total=False):
    """Arguments for Student"""
    take: int
    skip: int
    order_by: Union['AttendanceOrderByInput', List['AttendanceOrderByInput']]
    where: 'AttendanceWhereInput'
    cursor: 'AttendanceWhereUniqueInput'
    distinct: List['AttendanceScalarFieldKeys']
    include: 'AttendanceIncludeFromAttendance'




FindManyStudentArgs = FindManyStudentArgsFromStudent
FindFirstStudentArgs = FindManyStudentArgsFromStudent


class StudentWhereInput(TypedDict, total=False):
    """Student arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    class_id: Union[None, _int, 'types.IntFilter']
    roll_no: Union[None, _str, 'types.StringFilter']
    parent_id: Union[None, _int, 'types.IntFilter']
    email: Union[None, _str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    parent: 'ParentRelationFilter'
    classModel: 'ClassModelRelationFilter'
    results: 'ResultListRelationFilter'
    attendance: 'AttendanceListRelationFilter'

    # should be noted that AND and NOT should be Union['StudentWhereInput', List['StudentWhereInput']]
    # but this causes mypy to hang :/
    AND: List['StudentWhereInput']
    OR: List['StudentWhereInput']
    NOT: List['StudentWhereInput']



# aggregate Student types


class StudentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Student arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    class_id: Union[_int, 'types.IntWithAggregatesFilter']
    roll_no: Union[_str, 'types.StringWithAggregatesFilter']
    parent_id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['StudentScalarWhereWithAggregatesInput']
    OR: List['StudentScalarWhereWithAggregatesInput']
    NOT: List['StudentScalarWhereWithAggregatesInput']



class StudentGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    class_id: _int
    roll_no: _str
    parent_id: _int
    email: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'StudentSumAggregateOutput'
    _avg: 'StudentAvgAggregateOutput'
    _min: 'StudentMinAggregateOutput'
    _max: 'StudentMaxAggregateOutput'
    _count: 'StudentCountAggregateOutput'


class StudentAvgAggregateOutput(TypedDict, total=False):
    """Student output for aggregating averages"""
    id: float
    class_id: float
    parent_id: float


class StudentSumAggregateOutput(TypedDict, total=False):
    """Student output for aggregating sums"""
    id: _int
    class_id: _int
    parent_id: _int


class StudentScalarAggregateOutput(TypedDict, total=False):
    """Student output including scalar fields"""
    id: _int
    name: _str
    class_id: _int
    roll_no: _str
    parent_id: _int
    email: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


StudentMinAggregateOutput = StudentScalarAggregateOutput
StudentMaxAggregateOutput = StudentScalarAggregateOutput


class StudentMaxAggregateInput(TypedDict, total=False):
    """Student input for aggregating by max"""
    id: bool
    name: bool
    class_id: bool
    roll_no: bool
    parent_id: bool
    email: bool
    status: bool
    created_at: bool
    updated_at: bool


class StudentMinAggregateInput(TypedDict, total=False):
    """Student input for aggregating by min"""
    id: bool
    name: bool
    class_id: bool
    roll_no: bool
    parent_id: bool
    email: bool
    status: bool
    created_at: bool
    updated_at: bool


class StudentNumberAggregateInput(TypedDict, total=False):
    """Student input for aggregating numbers"""
    id: bool
    class_id: bool
    parent_id: bool


StudentAvgAggregateInput = StudentNumberAggregateInput
StudentSumAggregateInput = StudentNumberAggregateInput


StudentCountAggregateInput = TypedDict(
    'StudentCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'class_id': bool,
        'roll_no': bool,
        'parent_id': bool,
        'email': bool,
        'status': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

StudentCountAggregateOutput = TypedDict(
    'StudentCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'class_id': int,
        'roll_no': int,
        'parent_id': int,
        'email': int,
        'status': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


StudentKeys = Literal[
    'id',
    'name',
    'class_id',
    'roll_no',
    'parent_id',
    'email',
    'status',
    'created_at',
    'updated_at',
    'parent',
    'classModel',
    'results',
    'attendance',
]
StudentScalarFieldKeys = Literal[
    'id',
    'name',
    'class_id',
    'roll_no',
    'parent_id',
    'email',
    'status',
    'created_at',
    'updated_at',
]
StudentScalarFieldKeysT = TypeVar('StudentScalarFieldKeysT', bound=StudentScalarFieldKeys)

StudentRelationalFieldKeys = Literal[
        'parent',
        'classModel',
        'results',
        'attendance',
    ]

# Event types

class EventOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Event create method"""
    id: _int
    description: Optional[_str]
    date: Optional[_str]
    time: Optional[_str]
    type: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class EventCreateInput(EventOptionalCreateInput):
    """Required arguments to the Event create method"""
    title: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class EventOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Event create method, without relations"""
    id: _int
    description: Optional[_str]
    date: Optional[_str]
    time: Optional[_str]
    type: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class EventCreateWithoutRelationsInput(EventOptionalCreateWithoutRelationsInput):
    """Required arguments to the Event create method, without relations"""
    title: _str

class EventConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'EventCreateWithoutRelationsInput'
    where: 'EventWhereUniqueInput'

class EventCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'EventCreateWithoutRelationsInput'
    connect: 'EventWhereUniqueInput'
    connect_or_create: 'EventConnectOrCreateWithoutRelationsInput'


class EventCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['EventCreateWithoutRelationsInput', List['EventCreateWithoutRelationsInput']]
    connect: Union['EventWhereUniqueInput', List['EventWhereUniqueInput']]
    connect_or_create: Union['EventConnectOrCreateWithoutRelationsInput', List['EventConnectOrCreateWithoutRelationsInput']]

_EventWhereUnique_id_Input = TypedDict(
    '_EventWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

EventWhereUniqueInput = _EventWhereUnique_id_Input


class EventUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    title: _str
    description: Optional[_str]
    date: Optional[_str]
    time: Optional[_str]
    type: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class EventUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    title: _str
    description: Optional[_str]
    date: Optional[_str]
    time: Optional[_str]
    type: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class EventUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['EventCreateWithoutRelationsInput']
    connect: List['EventWhereUniqueInput']
    connect_or_create: List['EventConnectOrCreateWithoutRelationsInput']
    set: List['EventWhereUniqueInput']
    disconnect: List['EventWhereUniqueInput']
    delete: List['EventWhereUniqueInput']

    # TODO
    # update: List['EventUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['EventUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['EventScalarWhereInput']
    # upsert: List['EventUpserteWithWhereUniqueWithoutRelationsInput']


class EventUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'EventCreateWithoutRelationsInput'
    connect: 'EventWhereUniqueInput'
    connect_or_create: 'EventConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'EventUpdateInput'
    # upsert: 'EventUpsertWithoutRelationsInput'


class EventUpsertInput(TypedDict):
    create: 'EventCreateInput'
    update: 'EventUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Event_id_OrderByInput = TypedDict(
    '_Event_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Event_title_OrderByInput = TypedDict(
    '_Event_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Event_description_OrderByInput = TypedDict(
    '_Event_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Event_date_OrderByInput = TypedDict(
    '_Event_date_OrderByInput',
    {
        'date': 'SortOrder',
    },
    total=True
)

_Event_time_OrderByInput = TypedDict(
    '_Event_time_OrderByInput',
    {
        'time': 'SortOrder',
    },
    total=True
)

_Event_type_OrderByInput = TypedDict(
    '_Event_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Event_status_OrderByInput = TypedDict(
    '_Event_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Event_created_at_OrderByInput = TypedDict(
    '_Event_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Event_updated_at_OrderByInput = TypedDict(
    '_Event_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

EventOrderByInput = Union[
    '_Event_id_OrderByInput',
    '_Event_title_OrderByInput',
    '_Event_description_OrderByInput',
    '_Event_date_OrderByInput',
    '_Event_time_OrderByInput',
    '_Event_type_OrderByInput',
    '_Event_status_OrderByInput',
    '_Event_created_at_OrderByInput',
    '_Event_updated_at_OrderByInput',
]



# recursive Event types
# TODO: cleanup these types



EventRelationFilter = TypedDict(
    'EventRelationFilter',
    {
        'is': 'EventWhereInput',
        'is_not': 'EventWhereInput',
    },
    total=False,
)


class EventListRelationFilter(TypedDict, total=False):
    some: 'EventWhereInput'
    none: 'EventWhereInput'
    every: 'EventWhereInput'


class EventInclude(TypedDict, total=False):
    """Event relational arguments"""


class UserIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    parent: Union[bool, 'ParentArgsFromEvent']
    teacher: Union[bool, 'TeacherArgsFromEvent']
    sentMessages: Union[bool, 'FindManyMessageArgsFromEvent']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromEvent']


class UserArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class ParentIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    user: Union[bool, 'UserArgsFromEvent']
    students: Union[bool, 'FindManyStudentArgsFromEvent']


class ParentArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'ParentIncludeFromParent'


class FindManyParentArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['ParentOrderByInput', List['ParentOrderByInput']]
    where: 'ParentWhereInput'
    cursor: 'ParentWhereUniqueInput'
    distinct: List['ParentScalarFieldKeys']
    include: 'ParentIncludeFromParent'


class TeacherIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    user: Union[bool, 'UserArgsFromEvent']
    classes: Union[bool, 'FindManyClassModelArgsFromEvent']
    results: Union[bool, 'FindManyResultArgsFromEvent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromEvent']


class TeacherArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'TeacherIncludeFromTeacher'


class FindManyTeacherArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TeacherOrderByInput', List['TeacherOrderByInput']]
    where: 'TeacherWhereInput'
    cursor: 'TeacherWhereUniqueInput'
    distinct: List['TeacherScalarFieldKeys']
    include: 'TeacherIncludeFromTeacher'


class ClassModelIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    teacher: Union[bool, 'TeacherArgsFromEvent']
    students: Union[bool, 'FindManyStudentArgsFromEvent']
    results: Union[bool, 'FindManyResultArgsFromEvent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromEvent']


class ClassModelArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'ClassModelIncludeFromClassModel'


class FindManyClassModelArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['ClassModelOrderByInput', List['ClassModelOrderByInput']]
    where: 'ClassModelWhereInput'
    cursor: 'ClassModelWhereUniqueInput'
    distinct: List['ClassModelScalarFieldKeys']
    include: 'ClassModelIncludeFromClassModel'


class StudentIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    parent: Union[bool, 'ParentArgsFromEvent']
    classModel: Union[bool, 'ClassModelArgsFromEvent']
    results: Union[bool, 'FindManyResultArgsFromEvent']
    attendance: Union[bool, 'FindManyAttendanceArgsFromEvent']


class StudentArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'StudentIncludeFromStudent'


class FindManyStudentArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudent'


class EventIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""


class EventArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'EventIncludeFromEvent'


class FindManyEventArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEvent'


class MessageIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    sender: Union[bool, 'UserArgsFromEvent']
    recipient: Union[bool, 'UserArgsFromEvent']


class MessageArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ResultIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    student: Union[bool, 'StudentArgsFromEvent']
    classModel: Union[bool, 'ClassModelArgsFromEvent']
    teacher: Union[bool, 'TeacherArgsFromEvent']


class ResultArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'ResultIncludeFromResult'


class FindManyResultArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['ResultOrderByInput', List['ResultOrderByInput']]
    where: 'ResultWhereInput'
    cursor: 'ResultWhereUniqueInput'
    distinct: List['ResultScalarFieldKeys']
    include: 'ResultIncludeFromResult'


class AttendanceIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    student: Union[bool, 'StudentArgsFromEvent']
    classModel: Union[bool, 'ClassModelArgsFromEvent']
    teacher: Union[bool, 'TeacherArgsFromEvent']


class AttendanceArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'AttendanceIncludeFromAttendance'


class FindManyAttendanceArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['AttendanceOrderByInput', List['AttendanceOrderByInput']]
    where: 'AttendanceWhereInput'
    cursor: 'AttendanceWhereUniqueInput'
    distinct: List['AttendanceScalarFieldKeys']
    include: 'AttendanceIncludeFromAttendance'




FindManyEventArgs = FindManyEventArgsFromEvent
FindFirstEventArgs = FindManyEventArgsFromEvent


class EventWhereInput(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    title: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    date: Union[None, _str, 'types.StringFilter']
    time: Union[None, _str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['EventWhereInput', List['EventWhereInput']]
    # but this causes mypy to hang :/
    AND: List['EventWhereInput']
    OR: List['EventWhereInput']
    NOT: List['EventWhereInput']



# aggregate Event types


class EventScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    date: Union[_str, 'types.StringWithAggregatesFilter']
    time: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['EventScalarWhereWithAggregatesInput']
    OR: List['EventScalarWhereWithAggregatesInput']
    NOT: List['EventScalarWhereWithAggregatesInput']



class EventGroupByOutput(TypedDict, total=False):
    id: _int
    title: _str
    description: _str
    date: _str
    time: _str
    type: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'EventSumAggregateOutput'
    _avg: 'EventAvgAggregateOutput'
    _min: 'EventMinAggregateOutput'
    _max: 'EventMaxAggregateOutput'
    _count: 'EventCountAggregateOutput'


class EventAvgAggregateOutput(TypedDict, total=False):
    """Event output for aggregating averages"""
    id: float


class EventSumAggregateOutput(TypedDict, total=False):
    """Event output for aggregating sums"""
    id: _int


class EventScalarAggregateOutput(TypedDict, total=False):
    """Event output including scalar fields"""
    id: _int
    title: _str
    description: _str
    date: _str
    time: _str
    type: _str
    status: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


EventMinAggregateOutput = EventScalarAggregateOutput
EventMaxAggregateOutput = EventScalarAggregateOutput


class EventMaxAggregateInput(TypedDict, total=False):
    """Event input for aggregating by max"""
    id: bool
    title: bool
    description: bool
    date: bool
    time: bool
    type: bool
    status: bool
    created_at: bool
    updated_at: bool


class EventMinAggregateInput(TypedDict, total=False):
    """Event input for aggregating by min"""
    id: bool
    title: bool
    description: bool
    date: bool
    time: bool
    type: bool
    status: bool
    created_at: bool
    updated_at: bool


class EventNumberAggregateInput(TypedDict, total=False):
    """Event input for aggregating numbers"""
    id: bool


EventAvgAggregateInput = EventNumberAggregateInput
EventSumAggregateInput = EventNumberAggregateInput


EventCountAggregateInput = TypedDict(
    'EventCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'description': bool,
        'date': bool,
        'time': bool,
        'type': bool,
        'status': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

EventCountAggregateOutput = TypedDict(
    'EventCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'description': int,
        'date': int,
        'time': int,
        'type': int,
        'status': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


EventKeys = Literal[
    'id',
    'title',
    'description',
    'date',
    'time',
    'type',
    'status',
    'created_at',
    'updated_at',
]
EventScalarFieldKeys = Literal[
    'id',
    'title',
    'description',
    'date',
    'time',
    'type',
    'status',
    'created_at',
    'updated_at',
]
EventScalarFieldKeysT = TypeVar('EventScalarFieldKeysT', bound=EventScalarFieldKeys)

EventRelationalFieldKeys = _NoneType

# Message types

class MessageOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Message create method"""
    id: _int
    body: Optional[_str]
    sender_id: Optional[_int]
    recipient_id: Optional[_int]
    recipient_role: Optional[_str]
    created_at: Optional[_str]
    read_at: Optional[_str]
    priority: _str
    message_type: _str
    sender: 'UserCreateNestedWithoutRelationsInput'
    recipient: 'UserCreateNestedWithoutRelationsInput'


class MessageCreateInput(MessageOptionalCreateInput):
    """Required arguments to the Message create method"""
    subject: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MessageOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Message create method, without relations"""
    id: _int
    body: Optional[_str]
    sender_id: Optional[_int]
    recipient_id: Optional[_int]
    recipient_role: Optional[_str]
    created_at: Optional[_str]
    read_at: Optional[_str]
    priority: _str
    message_type: _str


class MessageCreateWithoutRelationsInput(MessageOptionalCreateWithoutRelationsInput):
    """Required arguments to the Message create method, without relations"""
    subject: _str

class MessageConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MessageCreateWithoutRelationsInput'
    where: 'MessageWhereUniqueInput'

class MessageCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MessageCreateWithoutRelationsInput'
    connect: 'MessageWhereUniqueInput'
    connect_or_create: 'MessageConnectOrCreateWithoutRelationsInput'


class MessageCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MessageCreateWithoutRelationsInput', List['MessageCreateWithoutRelationsInput']]
    connect: Union['MessageWhereUniqueInput', List['MessageWhereUniqueInput']]
    connect_or_create: Union['MessageConnectOrCreateWithoutRelationsInput', List['MessageConnectOrCreateWithoutRelationsInput']]

_MessageWhereUnique_id_Input = TypedDict(
    '_MessageWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

MessageWhereUniqueInput = _MessageWhereUnique_id_Input


class MessageUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    subject: _str
    body: Optional[_str]
    recipient_role: Optional[_str]
    created_at: Optional[_str]
    read_at: Optional[_str]
    priority: _str
    message_type: _str
    sender: 'UserUpdateOneWithoutRelationsInput'
    recipient: 'UserUpdateOneWithoutRelationsInput'


class MessageUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    subject: _str
    body: Optional[_str]
    recipient_role: Optional[_str]
    created_at: Optional[_str]
    read_at: Optional[_str]
    priority: _str
    message_type: _str


class MessageUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MessageCreateWithoutRelationsInput']
    connect: List['MessageWhereUniqueInput']
    connect_or_create: List['MessageConnectOrCreateWithoutRelationsInput']
    set: List['MessageWhereUniqueInput']
    disconnect: List['MessageWhereUniqueInput']
    delete: List['MessageWhereUniqueInput']

    # TODO
    # update: List['MessageUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MessageUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MessageScalarWhereInput']
    # upsert: List['MessageUpserteWithWhereUniqueWithoutRelationsInput']


class MessageUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MessageCreateWithoutRelationsInput'
    connect: 'MessageWhereUniqueInput'
    connect_or_create: 'MessageConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MessageUpdateInput'
    # upsert: 'MessageUpsertWithoutRelationsInput'


class MessageUpsertInput(TypedDict):
    create: 'MessageCreateInput'
    update: 'MessageUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Message_id_OrderByInput = TypedDict(
    '_Message_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Message_subject_OrderByInput = TypedDict(
    '_Message_subject_OrderByInput',
    {
        'subject': 'SortOrder',
    },
    total=True
)

_Message_body_OrderByInput = TypedDict(
    '_Message_body_OrderByInput',
    {
        'body': 'SortOrder',
    },
    total=True
)

_Message_sender_id_OrderByInput = TypedDict(
    '_Message_sender_id_OrderByInput',
    {
        'sender_id': 'SortOrder',
    },
    total=True
)

_Message_recipient_id_OrderByInput = TypedDict(
    '_Message_recipient_id_OrderByInput',
    {
        'recipient_id': 'SortOrder',
    },
    total=True
)

_Message_recipient_role_OrderByInput = TypedDict(
    '_Message_recipient_role_OrderByInput',
    {
        'recipient_role': 'SortOrder',
    },
    total=True
)

_Message_created_at_OrderByInput = TypedDict(
    '_Message_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Message_read_at_OrderByInput = TypedDict(
    '_Message_read_at_OrderByInput',
    {
        'read_at': 'SortOrder',
    },
    total=True
)

_Message_priority_OrderByInput = TypedDict(
    '_Message_priority_OrderByInput',
    {
        'priority': 'SortOrder',
    },
    total=True
)

_Message_message_type_OrderByInput = TypedDict(
    '_Message_message_type_OrderByInput',
    {
        'message_type': 'SortOrder',
    },
    total=True
)

MessageOrderByInput = Union[
    '_Message_id_OrderByInput',
    '_Message_subject_OrderByInput',
    '_Message_body_OrderByInput',
    '_Message_sender_id_OrderByInput',
    '_Message_recipient_id_OrderByInput',
    '_Message_recipient_role_OrderByInput',
    '_Message_created_at_OrderByInput',
    '_Message_read_at_OrderByInput',
    '_Message_priority_OrderByInput',
    '_Message_message_type_OrderByInput',
]



# recursive Message types
# TODO: cleanup these types



MessageRelationFilter = TypedDict(
    'MessageRelationFilter',
    {
        'is': 'MessageWhereInput',
        'is_not': 'MessageWhereInput',
    },
    total=False,
)


class MessageListRelationFilter(TypedDict, total=False):
    some: 'MessageWhereInput'
    none: 'MessageWhereInput'
    every: 'MessageWhereInput'


class MessageInclude(TypedDict, total=False):
    """Message relational arguments"""
    sender: Union[bool, 'UserArgsFromMessage']
    recipient: Union[bool, 'UserArgsFromMessage']


class UserIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    parent: Union[bool, 'ParentArgsFromMessage']
    teacher: Union[bool, 'TeacherArgsFromMessage']
    sentMessages: Union[bool, 'FindManyMessageArgsFromMessage']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromMessage']


class UserArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class ParentIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    user: Union[bool, 'UserArgsFromMessage']
    students: Union[bool, 'FindManyStudentArgsFromMessage']


class ParentArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'ParentIncludeFromParent'


class FindManyParentArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['ParentOrderByInput', List['ParentOrderByInput']]
    where: 'ParentWhereInput'
    cursor: 'ParentWhereUniqueInput'
    distinct: List['ParentScalarFieldKeys']
    include: 'ParentIncludeFromParent'


class TeacherIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    user: Union[bool, 'UserArgsFromMessage']
    classes: Union[bool, 'FindManyClassModelArgsFromMessage']
    results: Union[bool, 'FindManyResultArgsFromMessage']
    attendance: Union[bool, 'FindManyAttendanceArgsFromMessage']


class TeacherArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'TeacherIncludeFromTeacher'


class FindManyTeacherArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['TeacherOrderByInput', List['TeacherOrderByInput']]
    where: 'TeacherWhereInput'
    cursor: 'TeacherWhereUniqueInput'
    distinct: List['TeacherScalarFieldKeys']
    include: 'TeacherIncludeFromTeacher'


class ClassModelIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    teacher: Union[bool, 'TeacherArgsFromMessage']
    students: Union[bool, 'FindManyStudentArgsFromMessage']
    results: Union[bool, 'FindManyResultArgsFromMessage']
    attendance: Union[bool, 'FindManyAttendanceArgsFromMessage']


class ClassModelArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'ClassModelIncludeFromClassModel'


class FindManyClassModelArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['ClassModelOrderByInput', List['ClassModelOrderByInput']]
    where: 'ClassModelWhereInput'
    cursor: 'ClassModelWhereUniqueInput'
    distinct: List['ClassModelScalarFieldKeys']
    include: 'ClassModelIncludeFromClassModel'


class StudentIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    parent: Union[bool, 'ParentArgsFromMessage']
    classModel: Union[bool, 'ClassModelArgsFromMessage']
    results: Union[bool, 'FindManyResultArgsFromMessage']
    attendance: Union[bool, 'FindManyAttendanceArgsFromMessage']


class StudentArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'StudentIncludeFromStudent'


class FindManyStudentArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudent'


class EventIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""


class EventArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'EventIncludeFromEvent'


class FindManyEventArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEvent'


class MessageIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    sender: Union[bool, 'UserArgsFromMessage']
    recipient: Union[bool, 'UserArgsFromMessage']


class MessageArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ResultIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    student: Union[bool, 'StudentArgsFromMessage']
    classModel: Union[bool, 'ClassModelArgsFromMessage']
    teacher: Union[bool, 'TeacherArgsFromMessage']


class ResultArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'ResultIncludeFromResult'


class FindManyResultArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['ResultOrderByInput', List['ResultOrderByInput']]
    where: 'ResultWhereInput'
    cursor: 'ResultWhereUniqueInput'
    distinct: List['ResultScalarFieldKeys']
    include: 'ResultIncludeFromResult'


class AttendanceIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    student: Union[bool, 'StudentArgsFromMessage']
    classModel: Union[bool, 'ClassModelArgsFromMessage']
    teacher: Union[bool, 'TeacherArgsFromMessage']


class AttendanceArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'AttendanceIncludeFromAttendance'


class FindManyAttendanceArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['AttendanceOrderByInput', List['AttendanceOrderByInput']]
    where: 'AttendanceWhereInput'
    cursor: 'AttendanceWhereUniqueInput'
    distinct: List['AttendanceScalarFieldKeys']
    include: 'AttendanceIncludeFromAttendance'




FindManyMessageArgs = FindManyMessageArgsFromMessage
FindFirstMessageArgs = FindManyMessageArgsFromMessage


class MessageWhereInput(TypedDict, total=False):
    """Message arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    subject: Union[_str, 'types.StringFilter']
    body: Union[None, _str, 'types.StringFilter']
    sender_id: Union[None, _int, 'types.IntFilter']
    recipient_id: Union[None, _int, 'types.IntFilter']
    recipient_role: Union[None, _str, 'types.StringFilter']
    created_at: Union[None, _str, 'types.StringFilter']
    read_at: Union[None, _str, 'types.StringFilter']
    priority: Union[_str, 'types.StringFilter']
    message_type: Union[_str, 'types.StringFilter']
    sender: 'UserRelationFilter'
    recipient: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['MessageWhereInput', List['MessageWhereInput']]
    # but this causes mypy to hang :/
    AND: List['MessageWhereInput']
    OR: List['MessageWhereInput']
    NOT: List['MessageWhereInput']



# aggregate Message types


class MessageScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Message arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    subject: Union[_str, 'types.StringWithAggregatesFilter']
    body: Union[_str, 'types.StringWithAggregatesFilter']
    sender_id: Union[_int, 'types.IntWithAggregatesFilter']
    recipient_id: Union[_int, 'types.IntWithAggregatesFilter']
    recipient_role: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[_str, 'types.StringWithAggregatesFilter']
    read_at: Union[_str, 'types.StringWithAggregatesFilter']
    priority: Union[_str, 'types.StringWithAggregatesFilter']
    message_type: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MessageScalarWhereWithAggregatesInput']
    OR: List['MessageScalarWhereWithAggregatesInput']
    NOT: List['MessageScalarWhereWithAggregatesInput']



class MessageGroupByOutput(TypedDict, total=False):
    id: _int
    subject: _str
    body: _str
    sender_id: _int
    recipient_id: _int
    recipient_role: _str
    created_at: _str
    read_at: _str
    priority: _str
    message_type: _str
    _sum: 'MessageSumAggregateOutput'
    _avg: 'MessageAvgAggregateOutput'
    _min: 'MessageMinAggregateOutput'
    _max: 'MessageMaxAggregateOutput'
    _count: 'MessageCountAggregateOutput'


class MessageAvgAggregateOutput(TypedDict, total=False):
    """Message output for aggregating averages"""
    id: float
    sender_id: float
    recipient_id: float


class MessageSumAggregateOutput(TypedDict, total=False):
    """Message output for aggregating sums"""
    id: _int
    sender_id: _int
    recipient_id: _int


class MessageScalarAggregateOutput(TypedDict, total=False):
    """Message output including scalar fields"""
    id: _int
    subject: _str
    body: _str
    sender_id: _int
    recipient_id: _int
    recipient_role: _str
    created_at: _str
    read_at: _str
    priority: _str
    message_type: _str


MessageMinAggregateOutput = MessageScalarAggregateOutput
MessageMaxAggregateOutput = MessageScalarAggregateOutput


class MessageMaxAggregateInput(TypedDict, total=False):
    """Message input for aggregating by max"""
    id: bool
    subject: bool
    body: bool
    sender_id: bool
    recipient_id: bool
    recipient_role: bool
    created_at: bool
    read_at: bool
    priority: bool
    message_type: bool


class MessageMinAggregateInput(TypedDict, total=False):
    """Message input for aggregating by min"""
    id: bool
    subject: bool
    body: bool
    sender_id: bool
    recipient_id: bool
    recipient_role: bool
    created_at: bool
    read_at: bool
    priority: bool
    message_type: bool


class MessageNumberAggregateInput(TypedDict, total=False):
    """Message input for aggregating numbers"""
    id: bool
    sender_id: bool
    recipient_id: bool


MessageAvgAggregateInput = MessageNumberAggregateInput
MessageSumAggregateInput = MessageNumberAggregateInput


MessageCountAggregateInput = TypedDict(
    'MessageCountAggregateInput',
    {
        'id': bool,
        'subject': bool,
        'body': bool,
        'sender_id': bool,
        'recipient_id': bool,
        'recipient_role': bool,
        'created_at': bool,
        'read_at': bool,
        'priority': bool,
        'message_type': bool,
        '_all': bool,
    },
    total=False,
)

MessageCountAggregateOutput = TypedDict(
    'MessageCountAggregateOutput',
    {
        'id': int,
        'subject': int,
        'body': int,
        'sender_id': int,
        'recipient_id': int,
        'recipient_role': int,
        'created_at': int,
        'read_at': int,
        'priority': int,
        'message_type': int,
        '_all': int,
    },
    total=False,
)


MessageKeys = Literal[
    'id',
    'subject',
    'body',
    'sender_id',
    'recipient_id',
    'recipient_role',
    'created_at',
    'read_at',
    'priority',
    'message_type',
    'sender',
    'recipient',
]
MessageScalarFieldKeys = Literal[
    'id',
    'subject',
    'body',
    'sender_id',
    'recipient_id',
    'recipient_role',
    'created_at',
    'read_at',
    'priority',
    'message_type',
]
MessageScalarFieldKeysT = TypeVar('MessageScalarFieldKeysT', bound=MessageScalarFieldKeys)

MessageRelationalFieldKeys = Literal[
        'sender',
        'recipient',
    ]

# Result types

class ResultOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Result create method"""
    id: _int
    student_id: _int
    class_id: Optional[_int]
    teacher_id: _int
    date: Optional[_str]
    comments: Optional[_str]
    created_at: Optional[_str]
    updated_at: datetime.datetime
    student: 'StudentCreateNestedWithoutRelationsInput'
    classModel: 'ClassModelCreateNestedWithoutRelationsInput'
    teacher: 'TeacherCreateNestedWithoutRelationsInput'


class ResultCreateInput(ResultOptionalCreateInput):
    """Required arguments to the Result create method"""
    subject: _str
    term: _str
    score: _int
    grade: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ResultOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Result create method, without relations"""
    id: _int
    student_id: _int
    class_id: Optional[_int]
    teacher_id: _int
    date: Optional[_str]
    comments: Optional[_str]
    created_at: Optional[_str]
    updated_at: datetime.datetime


class ResultCreateWithoutRelationsInput(ResultOptionalCreateWithoutRelationsInput):
    """Required arguments to the Result create method, without relations"""
    subject: _str
    term: _str
    score: _int
    grade: _str

class ResultConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ResultCreateWithoutRelationsInput'
    where: 'ResultWhereUniqueInput'

class ResultCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ResultCreateWithoutRelationsInput'
    connect: 'ResultWhereUniqueInput'
    connect_or_create: 'ResultConnectOrCreateWithoutRelationsInput'


class ResultCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ResultCreateWithoutRelationsInput', List['ResultCreateWithoutRelationsInput']]
    connect: Union['ResultWhereUniqueInput', List['ResultWhereUniqueInput']]
    connect_or_create: Union['ResultConnectOrCreateWithoutRelationsInput', List['ResultConnectOrCreateWithoutRelationsInput']]

_ResultWhereUnique_id_Input = TypedDict(
    '_ResultWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

ResultWhereUniqueInput = _ResultWhereUnique_id_Input


class ResultUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    subject: _str
    term: _str
    score: Union[AtomicIntInput, _int]
    grade: _str
    date: Optional[_str]
    comments: Optional[_str]
    created_at: Optional[_str]
    updated_at: datetime.datetime
    student: 'StudentUpdateOneWithoutRelationsInput'
    classModel: 'ClassModelUpdateOneWithoutRelationsInput'
    teacher: 'TeacherUpdateOneWithoutRelationsInput'


class ResultUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    subject: _str
    term: _str
    score: Union[AtomicIntInput, _int]
    grade: _str
    date: Optional[_str]
    comments: Optional[_str]
    created_at: Optional[_str]
    updated_at: datetime.datetime


class ResultUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ResultCreateWithoutRelationsInput']
    connect: List['ResultWhereUniqueInput']
    connect_or_create: List['ResultConnectOrCreateWithoutRelationsInput']
    set: List['ResultWhereUniqueInput']
    disconnect: List['ResultWhereUniqueInput']
    delete: List['ResultWhereUniqueInput']

    # TODO
    # update: List['ResultUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ResultUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ResultScalarWhereInput']
    # upsert: List['ResultUpserteWithWhereUniqueWithoutRelationsInput']


class ResultUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ResultCreateWithoutRelationsInput'
    connect: 'ResultWhereUniqueInput'
    connect_or_create: 'ResultConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ResultUpdateInput'
    # upsert: 'ResultUpsertWithoutRelationsInput'


class ResultUpsertInput(TypedDict):
    create: 'ResultCreateInput'
    update: 'ResultUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Result_id_OrderByInput = TypedDict(
    '_Result_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Result_student_id_OrderByInput = TypedDict(
    '_Result_student_id_OrderByInput',
    {
        'student_id': 'SortOrder',
    },
    total=True
)

_Result_class_id_OrderByInput = TypedDict(
    '_Result_class_id_OrderByInput',
    {
        'class_id': 'SortOrder',
    },
    total=True
)

_Result_teacher_id_OrderByInput = TypedDict(
    '_Result_teacher_id_OrderByInput',
    {
        'teacher_id': 'SortOrder',
    },
    total=True
)

_Result_subject_OrderByInput = TypedDict(
    '_Result_subject_OrderByInput',
    {
        'subject': 'SortOrder',
    },
    total=True
)

_Result_term_OrderByInput = TypedDict(
    '_Result_term_OrderByInput',
    {
        'term': 'SortOrder',
    },
    total=True
)

_Result_score_OrderByInput = TypedDict(
    '_Result_score_OrderByInput',
    {
        'score': 'SortOrder',
    },
    total=True
)

_Result_grade_OrderByInput = TypedDict(
    '_Result_grade_OrderByInput',
    {
        'grade': 'SortOrder',
    },
    total=True
)

_Result_date_OrderByInput = TypedDict(
    '_Result_date_OrderByInput',
    {
        'date': 'SortOrder',
    },
    total=True
)

_Result_comments_OrderByInput = TypedDict(
    '_Result_comments_OrderByInput',
    {
        'comments': 'SortOrder',
    },
    total=True
)

_Result_created_at_OrderByInput = TypedDict(
    '_Result_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Result_updated_at_OrderByInput = TypedDict(
    '_Result_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

ResultOrderByInput = Union[
    '_Result_id_OrderByInput',
    '_Result_student_id_OrderByInput',
    '_Result_class_id_OrderByInput',
    '_Result_teacher_id_OrderByInput',
    '_Result_subject_OrderByInput',
    '_Result_term_OrderByInput',
    '_Result_score_OrderByInput',
    '_Result_grade_OrderByInput',
    '_Result_date_OrderByInput',
    '_Result_comments_OrderByInput',
    '_Result_created_at_OrderByInput',
    '_Result_updated_at_OrderByInput',
]



# recursive Result types
# TODO: cleanup these types



ResultRelationFilter = TypedDict(
    'ResultRelationFilter',
    {
        'is': 'ResultWhereInput',
        'is_not': 'ResultWhereInput',
    },
    total=False,
)


class ResultListRelationFilter(TypedDict, total=False):
    some: 'ResultWhereInput'
    none: 'ResultWhereInput'
    every: 'ResultWhereInput'


class ResultInclude(TypedDict, total=False):
    """Result relational arguments"""
    student: Union[bool, 'StudentArgsFromResult']
    classModel: Union[bool, 'ClassModelArgsFromResult']
    teacher: Union[bool, 'TeacherArgsFromResult']


class UserIncludeFromResult(TypedDict, total=False):
    """Relational arguments for Result"""
    parent: Union[bool, 'ParentArgsFromResult']
    teacher: Union[bool, 'TeacherArgsFromResult']
    sentMessages: Union[bool, 'FindManyMessageArgsFromResult']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromResult']


class UserArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class ParentIncludeFromResult(TypedDict, total=False):
    """Relational arguments for Result"""
    user: Union[bool, 'UserArgsFromResult']
    students: Union[bool, 'FindManyStudentArgsFromResult']


class ParentArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    include: 'ParentIncludeFromParent'


class FindManyParentArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    take: int
    skip: int
    order_by: Union['ParentOrderByInput', List['ParentOrderByInput']]
    where: 'ParentWhereInput'
    cursor: 'ParentWhereUniqueInput'
    distinct: List['ParentScalarFieldKeys']
    include: 'ParentIncludeFromParent'


class TeacherIncludeFromResult(TypedDict, total=False):
    """Relational arguments for Result"""
    user: Union[bool, 'UserArgsFromResult']
    classes: Union[bool, 'FindManyClassModelArgsFromResult']
    results: Union[bool, 'FindManyResultArgsFromResult']
    attendance: Union[bool, 'FindManyAttendanceArgsFromResult']


class TeacherArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    include: 'TeacherIncludeFromTeacher'


class FindManyTeacherArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    take: int
    skip: int
    order_by: Union['TeacherOrderByInput', List['TeacherOrderByInput']]
    where: 'TeacherWhereInput'
    cursor: 'TeacherWhereUniqueInput'
    distinct: List['TeacherScalarFieldKeys']
    include: 'TeacherIncludeFromTeacher'


class ClassModelIncludeFromResult(TypedDict, total=False):
    """Relational arguments for Result"""
    teacher: Union[bool, 'TeacherArgsFromResult']
    students: Union[bool, 'FindManyStudentArgsFromResult']
    results: Union[bool, 'FindManyResultArgsFromResult']
    attendance: Union[bool, 'FindManyAttendanceArgsFromResult']


class ClassModelArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    include: 'ClassModelIncludeFromClassModel'


class FindManyClassModelArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    take: int
    skip: int
    order_by: Union['ClassModelOrderByInput', List['ClassModelOrderByInput']]
    where: 'ClassModelWhereInput'
    cursor: 'ClassModelWhereUniqueInput'
    distinct: List['ClassModelScalarFieldKeys']
    include: 'ClassModelIncludeFromClassModel'


class StudentIncludeFromResult(TypedDict, total=False):
    """Relational arguments for Result"""
    parent: Union[bool, 'ParentArgsFromResult']
    classModel: Union[bool, 'ClassModelArgsFromResult']
    results: Union[bool, 'FindManyResultArgsFromResult']
    attendance: Union[bool, 'FindManyAttendanceArgsFromResult']


class StudentArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    include: 'StudentIncludeFromStudent'


class FindManyStudentArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudent'


class EventIncludeFromResult(TypedDict, total=False):
    """Relational arguments for Result"""


class EventArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    include: 'EventIncludeFromEvent'


class FindManyEventArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEvent'


class MessageIncludeFromResult(TypedDict, total=False):
    """Relational arguments for Result"""
    sender: Union[bool, 'UserArgsFromResult']
    recipient: Union[bool, 'UserArgsFromResult']


class MessageArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ResultIncludeFromResult(TypedDict, total=False):
    """Relational arguments for Result"""
    student: Union[bool, 'StudentArgsFromResult']
    classModel: Union[bool, 'ClassModelArgsFromResult']
    teacher: Union[bool, 'TeacherArgsFromResult']


class ResultArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    include: 'ResultIncludeFromResult'


class FindManyResultArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    take: int
    skip: int
    order_by: Union['ResultOrderByInput', List['ResultOrderByInput']]
    where: 'ResultWhereInput'
    cursor: 'ResultWhereUniqueInput'
    distinct: List['ResultScalarFieldKeys']
    include: 'ResultIncludeFromResult'


class AttendanceIncludeFromResult(TypedDict, total=False):
    """Relational arguments for Result"""
    student: Union[bool, 'StudentArgsFromResult']
    classModel: Union[bool, 'ClassModelArgsFromResult']
    teacher: Union[bool, 'TeacherArgsFromResult']


class AttendanceArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    include: 'AttendanceIncludeFromAttendance'


class FindManyAttendanceArgsFromResult(TypedDict, total=False):
    """Arguments for Result"""
    take: int
    skip: int
    order_by: Union['AttendanceOrderByInput', List['AttendanceOrderByInput']]
    where: 'AttendanceWhereInput'
    cursor: 'AttendanceWhereUniqueInput'
    distinct: List['AttendanceScalarFieldKeys']
    include: 'AttendanceIncludeFromAttendance'




FindManyResultArgs = FindManyResultArgsFromResult
FindFirstResultArgs = FindManyResultArgsFromResult


class ResultWhereInput(TypedDict, total=False):
    """Result arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    student_id: Union[_int, 'types.IntFilter']
    class_id: Union[None, _int, 'types.IntFilter']
    teacher_id: Union[_int, 'types.IntFilter']
    subject: Union[_str, 'types.StringFilter']
    term: Union[_str, 'types.StringFilter']
    score: Union[_int, 'types.IntFilter']
    grade: Union[_str, 'types.StringFilter']
    date: Union[None, _str, 'types.StringFilter']
    comments: Union[None, _str, 'types.StringFilter']
    created_at: Union[None, _str, 'types.StringFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    student: 'StudentRelationFilter'
    classModel: 'ClassModelRelationFilter'
    teacher: 'TeacherRelationFilter'

    # should be noted that AND and NOT should be Union['ResultWhereInput', List['ResultWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ResultWhereInput']
    OR: List['ResultWhereInput']
    NOT: List['ResultWhereInput']



# aggregate Result types


class ResultScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Result arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    student_id: Union[_int, 'types.IntWithAggregatesFilter']
    class_id: Union[_int, 'types.IntWithAggregatesFilter']
    teacher_id: Union[_int, 'types.IntWithAggregatesFilter']
    subject: Union[_str, 'types.StringWithAggregatesFilter']
    term: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_int, 'types.IntWithAggregatesFilter']
    grade: Union[_str, 'types.StringWithAggregatesFilter']
    date: Union[_str, 'types.StringWithAggregatesFilter']
    comments: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[_str, 'types.StringWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ResultScalarWhereWithAggregatesInput']
    OR: List['ResultScalarWhereWithAggregatesInput']
    NOT: List['ResultScalarWhereWithAggregatesInput']



class ResultGroupByOutput(TypedDict, total=False):
    id: _int
    student_id: _int
    class_id: _int
    teacher_id: _int
    subject: _str
    term: _str
    score: _int
    grade: _str
    date: _str
    comments: _str
    created_at: _str
    updated_at: datetime.datetime
    _sum: 'ResultSumAggregateOutput'
    _avg: 'ResultAvgAggregateOutput'
    _min: 'ResultMinAggregateOutput'
    _max: 'ResultMaxAggregateOutput'
    _count: 'ResultCountAggregateOutput'


class ResultAvgAggregateOutput(TypedDict, total=False):
    """Result output for aggregating averages"""
    id: float
    student_id: float
    class_id: float
    teacher_id: float
    score: float


class ResultSumAggregateOutput(TypedDict, total=False):
    """Result output for aggregating sums"""
    id: _int
    student_id: _int
    class_id: _int
    teacher_id: _int
    score: _int


class ResultScalarAggregateOutput(TypedDict, total=False):
    """Result output including scalar fields"""
    id: _int
    student_id: _int
    class_id: _int
    teacher_id: _int
    subject: _str
    term: _str
    score: _int
    grade: _str
    date: _str
    comments: _str
    created_at: _str
    updated_at: datetime.datetime


ResultMinAggregateOutput = ResultScalarAggregateOutput
ResultMaxAggregateOutput = ResultScalarAggregateOutput


class ResultMaxAggregateInput(TypedDict, total=False):
    """Result input for aggregating by max"""
    id: bool
    student_id: bool
    class_id: bool
    teacher_id: bool
    subject: bool
    term: bool
    score: bool
    grade: bool
    date: bool
    comments: bool
    created_at: bool
    updated_at: bool


class ResultMinAggregateInput(TypedDict, total=False):
    """Result input for aggregating by min"""
    id: bool
    student_id: bool
    class_id: bool
    teacher_id: bool
    subject: bool
    term: bool
    score: bool
    grade: bool
    date: bool
    comments: bool
    created_at: bool
    updated_at: bool


class ResultNumberAggregateInput(TypedDict, total=False):
    """Result input for aggregating numbers"""
    id: bool
    student_id: bool
    class_id: bool
    teacher_id: bool
    score: bool


ResultAvgAggregateInput = ResultNumberAggregateInput
ResultSumAggregateInput = ResultNumberAggregateInput


ResultCountAggregateInput = TypedDict(
    'ResultCountAggregateInput',
    {
        'id': bool,
        'student_id': bool,
        'class_id': bool,
        'teacher_id': bool,
        'subject': bool,
        'term': bool,
        'score': bool,
        'grade': bool,
        'date': bool,
        'comments': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

ResultCountAggregateOutput = TypedDict(
    'ResultCountAggregateOutput',
    {
        'id': int,
        'student_id': int,
        'class_id': int,
        'teacher_id': int,
        'subject': int,
        'term': int,
        'score': int,
        'grade': int,
        'date': int,
        'comments': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


ResultKeys = Literal[
    'id',
    'student_id',
    'class_id',
    'teacher_id',
    'subject',
    'term',
    'score',
    'grade',
    'date',
    'comments',
    'created_at',
    'updated_at',
    'student',
    'classModel',
    'teacher',
]
ResultScalarFieldKeys = Literal[
    'id',
    'student_id',
    'class_id',
    'teacher_id',
    'subject',
    'term',
    'score',
    'grade',
    'date',
    'comments',
    'created_at',
    'updated_at',
]
ResultScalarFieldKeysT = TypeVar('ResultScalarFieldKeysT', bound=ResultScalarFieldKeys)

ResultRelationalFieldKeys = Literal[
        'student',
        'classModel',
        'teacher',
    ]

# Attendance types

class AttendanceOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Attendance create method"""
    id: _int
    student_id: _int
    class_id: Optional[_int]
    teacher_id: _int
    notes: Optional[_str]
    created_at: Optional[_str]
    updated_at: datetime.datetime
    student: 'StudentCreateNestedWithoutRelationsInput'
    classModel: 'ClassModelCreateNestedWithoutRelationsInput'
    teacher: 'TeacherCreateNestedWithoutRelationsInput'


class AttendanceCreateInput(AttendanceOptionalCreateInput):
    """Required arguments to the Attendance create method"""
    date: _str
    status: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AttendanceOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Attendance create method, without relations"""
    id: _int
    student_id: _int
    class_id: Optional[_int]
    teacher_id: _int
    notes: Optional[_str]
    created_at: Optional[_str]
    updated_at: datetime.datetime


class AttendanceCreateWithoutRelationsInput(AttendanceOptionalCreateWithoutRelationsInput):
    """Required arguments to the Attendance create method, without relations"""
    date: _str
    status: _str

class AttendanceConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AttendanceCreateWithoutRelationsInput'
    where: 'AttendanceWhereUniqueInput'

class AttendanceCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AttendanceCreateWithoutRelationsInput'
    connect: 'AttendanceWhereUniqueInput'
    connect_or_create: 'AttendanceConnectOrCreateWithoutRelationsInput'


class AttendanceCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AttendanceCreateWithoutRelationsInput', List['AttendanceCreateWithoutRelationsInput']]
    connect: Union['AttendanceWhereUniqueInput', List['AttendanceWhereUniqueInput']]
    connect_or_create: Union['AttendanceConnectOrCreateWithoutRelationsInput', List['AttendanceConnectOrCreateWithoutRelationsInput']]

_AttendanceWhereUnique_id_Input = TypedDict(
    '_AttendanceWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_AttendanceCompoundstudent_id_dateKeyInner = TypedDict(
    '_AttendanceCompoundstudent_id_dateKeyInner',
    {
        'student_id': '_int',
        'date': '_str',
    },
    total=True
)

_AttendanceCompoundstudent_id_dateKey = TypedDict(
    '_AttendanceCompoundstudent_id_dateKey',
    {
        'student_id_date': '_AttendanceCompoundstudent_id_dateKeyInner',
    },
    total=True
)

AttendanceWhereUniqueInput = Union[
    '_AttendanceWhereUnique_id_Input',
    '_AttendanceCompoundstudent_id_dateKey',
]


class AttendanceUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    date: _str
    status: _str
    notes: Optional[_str]
    created_at: Optional[_str]
    updated_at: datetime.datetime
    student: 'StudentUpdateOneWithoutRelationsInput'
    classModel: 'ClassModelUpdateOneWithoutRelationsInput'
    teacher: 'TeacherUpdateOneWithoutRelationsInput'


class AttendanceUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    date: _str
    status: _str
    notes: Optional[_str]
    created_at: Optional[_str]
    updated_at: datetime.datetime


class AttendanceUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AttendanceCreateWithoutRelationsInput']
    connect: List['AttendanceWhereUniqueInput']
    connect_or_create: List['AttendanceConnectOrCreateWithoutRelationsInput']
    set: List['AttendanceWhereUniqueInput']
    disconnect: List['AttendanceWhereUniqueInput']
    delete: List['AttendanceWhereUniqueInput']

    # TODO
    # update: List['AttendanceUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AttendanceUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AttendanceScalarWhereInput']
    # upsert: List['AttendanceUpserteWithWhereUniqueWithoutRelationsInput']


class AttendanceUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AttendanceCreateWithoutRelationsInput'
    connect: 'AttendanceWhereUniqueInput'
    connect_or_create: 'AttendanceConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AttendanceUpdateInput'
    # upsert: 'AttendanceUpsertWithoutRelationsInput'


class AttendanceUpsertInput(TypedDict):
    create: 'AttendanceCreateInput'
    update: 'AttendanceUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Attendance_id_OrderByInput = TypedDict(
    '_Attendance_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Attendance_student_id_OrderByInput = TypedDict(
    '_Attendance_student_id_OrderByInput',
    {
        'student_id': 'SortOrder',
    },
    total=True
)

_Attendance_class_id_OrderByInput = TypedDict(
    '_Attendance_class_id_OrderByInput',
    {
        'class_id': 'SortOrder',
    },
    total=True
)

_Attendance_teacher_id_OrderByInput = TypedDict(
    '_Attendance_teacher_id_OrderByInput',
    {
        'teacher_id': 'SortOrder',
    },
    total=True
)

_Attendance_date_OrderByInput = TypedDict(
    '_Attendance_date_OrderByInput',
    {
        'date': 'SortOrder',
    },
    total=True
)

_Attendance_status_OrderByInput = TypedDict(
    '_Attendance_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Attendance_notes_OrderByInput = TypedDict(
    '_Attendance_notes_OrderByInput',
    {
        'notes': 'SortOrder',
    },
    total=True
)

_Attendance_created_at_OrderByInput = TypedDict(
    '_Attendance_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Attendance_updated_at_OrderByInput = TypedDict(
    '_Attendance_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

AttendanceOrderByInput = Union[
    '_Attendance_id_OrderByInput',
    '_Attendance_student_id_OrderByInput',
    '_Attendance_class_id_OrderByInput',
    '_Attendance_teacher_id_OrderByInput',
    '_Attendance_date_OrderByInput',
    '_Attendance_status_OrderByInput',
    '_Attendance_notes_OrderByInput',
    '_Attendance_created_at_OrderByInput',
    '_Attendance_updated_at_OrderByInput',
]



# recursive Attendance types
# TODO: cleanup these types



AttendanceRelationFilter = TypedDict(
    'AttendanceRelationFilter',
    {
        'is': 'AttendanceWhereInput',
        'is_not': 'AttendanceWhereInput',
    },
    total=False,
)


class AttendanceListRelationFilter(TypedDict, total=False):
    some: 'AttendanceWhereInput'
    none: 'AttendanceWhereInput'
    every: 'AttendanceWhereInput'


class AttendanceInclude(TypedDict, total=False):
    """Attendance relational arguments"""
    student: Union[bool, 'StudentArgsFromAttendance']
    classModel: Union[bool, 'ClassModelArgsFromAttendance']
    teacher: Union[bool, 'TeacherArgsFromAttendance']


class UserIncludeFromAttendance(TypedDict, total=False):
    """Relational arguments for Attendance"""
    parent: Union[bool, 'ParentArgsFromAttendance']
    teacher: Union[bool, 'TeacherArgsFromAttendance']
    sentMessages: Union[bool, 'FindManyMessageArgsFromAttendance']
    receivedMessages: Union[bool, 'FindManyMessageArgsFromAttendance']


class UserArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class ParentIncludeFromAttendance(TypedDict, total=False):
    """Relational arguments for Attendance"""
    user: Union[bool, 'UserArgsFromAttendance']
    students: Union[bool, 'FindManyStudentArgsFromAttendance']


class ParentArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    include: 'ParentIncludeFromParent'


class FindManyParentArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    take: int
    skip: int
    order_by: Union['ParentOrderByInput', List['ParentOrderByInput']]
    where: 'ParentWhereInput'
    cursor: 'ParentWhereUniqueInput'
    distinct: List['ParentScalarFieldKeys']
    include: 'ParentIncludeFromParent'


class TeacherIncludeFromAttendance(TypedDict, total=False):
    """Relational arguments for Attendance"""
    user: Union[bool, 'UserArgsFromAttendance']
    classes: Union[bool, 'FindManyClassModelArgsFromAttendance']
    results: Union[bool, 'FindManyResultArgsFromAttendance']
    attendance: Union[bool, 'FindManyAttendanceArgsFromAttendance']


class TeacherArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    include: 'TeacherIncludeFromTeacher'


class FindManyTeacherArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    take: int
    skip: int
    order_by: Union['TeacherOrderByInput', List['TeacherOrderByInput']]
    where: 'TeacherWhereInput'
    cursor: 'TeacherWhereUniqueInput'
    distinct: List['TeacherScalarFieldKeys']
    include: 'TeacherIncludeFromTeacher'


class ClassModelIncludeFromAttendance(TypedDict, total=False):
    """Relational arguments for Attendance"""
    teacher: Union[bool, 'TeacherArgsFromAttendance']
    students: Union[bool, 'FindManyStudentArgsFromAttendance']
    results: Union[bool, 'FindManyResultArgsFromAttendance']
    attendance: Union[bool, 'FindManyAttendanceArgsFromAttendance']


class ClassModelArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    include: 'ClassModelIncludeFromClassModel'


class FindManyClassModelArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    take: int
    skip: int
    order_by: Union['ClassModelOrderByInput', List['ClassModelOrderByInput']]
    where: 'ClassModelWhereInput'
    cursor: 'ClassModelWhereUniqueInput'
    distinct: List['ClassModelScalarFieldKeys']
    include: 'ClassModelIncludeFromClassModel'


class StudentIncludeFromAttendance(TypedDict, total=False):
    """Relational arguments for Attendance"""
    parent: Union[bool, 'ParentArgsFromAttendance']
    classModel: Union[bool, 'ClassModelArgsFromAttendance']
    results: Union[bool, 'FindManyResultArgsFromAttendance']
    attendance: Union[bool, 'FindManyAttendanceArgsFromAttendance']


class StudentArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    include: 'StudentIncludeFromStudent'


class FindManyStudentArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    take: int
    skip: int
    order_by: Union['StudentOrderByInput', List['StudentOrderByInput']]
    where: 'StudentWhereInput'
    cursor: 'StudentWhereUniqueInput'
    distinct: List['StudentScalarFieldKeys']
    include: 'StudentIncludeFromStudent'


class EventIncludeFromAttendance(TypedDict, total=False):
    """Relational arguments for Attendance"""


class EventArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    include: 'EventIncludeFromEvent'


class FindManyEventArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEvent'


class MessageIncludeFromAttendance(TypedDict, total=False):
    """Relational arguments for Attendance"""
    sender: Union[bool, 'UserArgsFromAttendance']
    recipient: Union[bool, 'UserArgsFromAttendance']


class MessageArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ResultIncludeFromAttendance(TypedDict, total=False):
    """Relational arguments for Attendance"""
    student: Union[bool, 'StudentArgsFromAttendance']
    classModel: Union[bool, 'ClassModelArgsFromAttendance']
    teacher: Union[bool, 'TeacherArgsFromAttendance']


class ResultArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    include: 'ResultIncludeFromResult'


class FindManyResultArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    take: int
    skip: int
    order_by: Union['ResultOrderByInput', List['ResultOrderByInput']]
    where: 'ResultWhereInput'
    cursor: 'ResultWhereUniqueInput'
    distinct: List['ResultScalarFieldKeys']
    include: 'ResultIncludeFromResult'


class AttendanceIncludeFromAttendance(TypedDict, total=False):
    """Relational arguments for Attendance"""
    student: Union[bool, 'StudentArgsFromAttendance']
    classModel: Union[bool, 'ClassModelArgsFromAttendance']
    teacher: Union[bool, 'TeacherArgsFromAttendance']


class AttendanceArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    include: 'AttendanceIncludeFromAttendance'


class FindManyAttendanceArgsFromAttendance(TypedDict, total=False):
    """Arguments for Attendance"""
    take: int
    skip: int
    order_by: Union['AttendanceOrderByInput', List['AttendanceOrderByInput']]
    where: 'AttendanceWhereInput'
    cursor: 'AttendanceWhereUniqueInput'
    distinct: List['AttendanceScalarFieldKeys']
    include: 'AttendanceIncludeFromAttendance'




FindManyAttendanceArgs = FindManyAttendanceArgsFromAttendance
FindFirstAttendanceArgs = FindManyAttendanceArgsFromAttendance


class AttendanceWhereInput(TypedDict, total=False):
    """Attendance arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    student_id: Union[_int, 'types.IntFilter']
    class_id: Union[None, _int, 'types.IntFilter']
    teacher_id: Union[_int, 'types.IntFilter']
    date: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']
    created_at: Union[None, _str, 'types.StringFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    student: 'StudentRelationFilter'
    classModel: 'ClassModelRelationFilter'
    teacher: 'TeacherRelationFilter'

    # should be noted that AND and NOT should be Union['AttendanceWhereInput', List['AttendanceWhereInput']]
    # but this causes mypy to hang :/
    AND: List['AttendanceWhereInput']
    OR: List['AttendanceWhereInput']
    NOT: List['AttendanceWhereInput']



# aggregate Attendance types


class AttendanceScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Attendance arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    student_id: Union[_int, 'types.IntWithAggregatesFilter']
    class_id: Union[_int, 'types.IntWithAggregatesFilter']
    teacher_id: Union[_int, 'types.IntWithAggregatesFilter']
    date: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[_str, 'types.StringWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AttendanceScalarWhereWithAggregatesInput']
    OR: List['AttendanceScalarWhereWithAggregatesInput']
    NOT: List['AttendanceScalarWhereWithAggregatesInput']



class AttendanceGroupByOutput(TypedDict, total=False):
    id: _int
    student_id: _int
    class_id: _int
    teacher_id: _int
    date: _str
    status: _str
    notes: _str
    created_at: _str
    updated_at: datetime.datetime
    _sum: 'AttendanceSumAggregateOutput'
    _avg: 'AttendanceAvgAggregateOutput'
    _min: 'AttendanceMinAggregateOutput'
    _max: 'AttendanceMaxAggregateOutput'
    _count: 'AttendanceCountAggregateOutput'


class AttendanceAvgAggregateOutput(TypedDict, total=False):
    """Attendance output for aggregating averages"""
    id: float
    student_id: float
    class_id: float
    teacher_id: float


class AttendanceSumAggregateOutput(TypedDict, total=False):
    """Attendance output for aggregating sums"""
    id: _int
    student_id: _int
    class_id: _int
    teacher_id: _int


class AttendanceScalarAggregateOutput(TypedDict, total=False):
    """Attendance output including scalar fields"""
    id: _int
    student_id: _int
    class_id: _int
    teacher_id: _int
    date: _str
    status: _str
    notes: _str
    created_at: _str
    updated_at: datetime.datetime


AttendanceMinAggregateOutput = AttendanceScalarAggregateOutput
AttendanceMaxAggregateOutput = AttendanceScalarAggregateOutput


class AttendanceMaxAggregateInput(TypedDict, total=False):
    """Attendance input for aggregating by max"""
    id: bool
    student_id: bool
    class_id: bool
    teacher_id: bool
    date: bool
    status: bool
    notes: bool
    created_at: bool
    updated_at: bool


class AttendanceMinAggregateInput(TypedDict, total=False):
    """Attendance input for aggregating by min"""
    id: bool
    student_id: bool
    class_id: bool
    teacher_id: bool
    date: bool
    status: bool
    notes: bool
    created_at: bool
    updated_at: bool


class AttendanceNumberAggregateInput(TypedDict, total=False):
    """Attendance input for aggregating numbers"""
    id: bool
    student_id: bool
    class_id: bool
    teacher_id: bool


AttendanceAvgAggregateInput = AttendanceNumberAggregateInput
AttendanceSumAggregateInput = AttendanceNumberAggregateInput


AttendanceCountAggregateInput = TypedDict(
    'AttendanceCountAggregateInput',
    {
        'id': bool,
        'student_id': bool,
        'class_id': bool,
        'teacher_id': bool,
        'date': bool,
        'status': bool,
        'notes': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

AttendanceCountAggregateOutput = TypedDict(
    'AttendanceCountAggregateOutput',
    {
        'id': int,
        'student_id': int,
        'class_id': int,
        'teacher_id': int,
        'date': int,
        'status': int,
        'notes': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


AttendanceKeys = Literal[
    'id',
    'student_id',
    'class_id',
    'teacher_id',
    'date',
    'status',
    'notes',
    'created_at',
    'updated_at',
    'student',
    'classModel',
    'teacher',
]
AttendanceScalarFieldKeys = Literal[
    'id',
    'student_id',
    'class_id',
    'teacher_id',
    'date',
    'status',
    'notes',
    'created_at',
    'updated_at',
]
AttendanceScalarFieldKeysT = TypeVar('AttendanceScalarFieldKeysT', bound=AttendanceScalarFieldKeys)

AttendanceRelationalFieldKeys = Literal[
        'student',
        'classModel',
        'teacher',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields